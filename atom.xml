<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>回忆宫殿</title>
  
  <subtitle>MemoryPalace</subtitle>
  <link href="https://mralridge.github.io/atom.xml" rel="self"/>
  
  <link href="https://mralridge.github.io/"/>
  <updated>2024-07-20T09:25:19.716Z</updated>
  <id>https://mralridge.github.io/</id>
  
  <author>
    <name>F10atingHeart</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>北大侠客行指令列表</title>
    <link href="https://mralridge.github.io/2024/07/20/%E5%8C%97%E5%A4%A7%E4%BE%A0%E5%AE%A2%E8%A1%8C%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/"/>
    <id>https://mralridge.github.io/2024/07/20/%E5%8C%97%E5%A4%A7%E4%BE%A0%E5%AE%A2%E8%A1%8C%E6%8C%87%E4%BB%A4%E5%88%97%E8%A1%A8/</id>
    <published>2024-07-20T09:24:33.000Z</published>
    <updated>2024-07-20T09:25:19.716Z</updated>
    
    <content type="html"><![CDATA[<p>纯文字不带样式的指令列表实在是看的眼疼，就整理了这一份文档</p><h2 id="标准命令"><a href="#标准命令" class="headerlink" title="标准命令"></a>标准命令</h2><h3 id="ask-sb-about-sth"><a href="#ask-sb-about-sth" class="headerlink" title="ask sb about sth"></a>ask <code>sb</code> about <code>sth</code></h3><p>向别人打探某件事情，<code>sb</code> 是指别人的id，这个命令在解谜时很重要，通常需要ask才能获得进一步的信息</p><h3 id="auto-reply"><a href="#auto-reply" class="headerlink" title="auto_reply"></a>auto_reply</h3><p>设定自动回复信息</p><h3 id="beg-sth-from-sb"><a href="#beg-sth-from-sb" class="headerlink" title="beg sth from sb"></a>beg <code>sth</code> from <code>sb</code></h3><p>向某人乞讨，丐帮弟子才能使用</p><h3 id="changewield"><a href="#changewield" class="headerlink" title="changewield"></a>changewield</h3><p>交换左右两手的武器</p><h3 id="check-sb"><a href="#check-sb" class="headerlink" title="check sb"></a>check <code>sb</code></h3><p>打听别人技能，丐帮弟子才能使用</p><h3 id="close-men，close-door"><a href="#close-men，close-door" class="headerlink" title="close men，close door"></a>close men，close door</h3><p>关门</p><h3 id="drop-sth"><a href="#drop-sth" class="headerlink" title="drop sth"></a>drop <code>sth</code></h3><p>丢弃某种物品</p><h3 id="emote"><a href="#emote" class="headerlink" title="emote"></a>emote</h3><p>做一个系统没有定义的动作</p><h3 id="fight-sb"><a href="#fight-sb" class="headerlink" title="fight sb"></a>fight <code>sb</code></h3><p>要求别人与你进行战斗，这种形式的战斗是点到为止</p><h3 id="follow-sb"><a href="#follow-sb" class="headerlink" title="follow sb"></a>follow <code>sb</code></h3><p>跟随别人一起行动</p><h3 id="get-sth-；get-all"><a href="#get-sth-；get-all" class="headerlink" title="get sth ；get all"></a>get <code>sth</code> ；get all</h3><p>捡起物品</p><h3 id="give-sb-sth；give-sth-to-sb"><a href="#give-sb-sth；give-sth-to-sb" class="headerlink" title="give sb sth；give sth to sb"></a>give <code>sb</code> <code>sth</code>；give <code>sth</code> to <code>sb</code></h3><p>给别人东西</p><h3 id="go-方向-或者直接用方向"><a href="#go-方向-或者直接用方向" class="headerlink" title="go 方向 或者直接用方向"></a>go <code>方向</code> 或者直接用<code>方向</code></h3><p>移动到某个方向</p><h3 id="guard-方向-；guard-sb-；guard-sth"><a href="#guard-方向-；guard-sb-；guard-sth" class="headerlink" title="guard 方向 ；guard sb ；guard sth"></a>guard <code>方向</code> ；guard <code>sb</code> ；guard <code>sth</code></h3><p>守卫某个方向，物品或人物</p><h3 id="halt"><a href="#halt" class="headerlink" title="halt"></a>halt</h3><p>强行中止正在进行的动作</p><h3 id="hit-sb"><a href="#hit-sb" class="headerlink" title="hit sb"></a>hit <code>sb</code></h3><p>强迫对方与你战斗，可以一直<code>hit</code>直到对方昏迷</p><h3 id="hitall-sb-；hitall"><a href="#hitall-sb-；hitall" class="headerlink" title="hitall sb ；hitall"></a>hitall <code>sb</code> ；hitall</h3><p>强迫同一房间内的所有npc与你战斗</p><h3 id="kill-sb"><a href="#kill-sb" class="headerlink" title="kill sb"></a>kill <code>sb</code></h3><p>主动开始攻击一个人物，并且试图杀死对方。如果对方是 <code>NPC</code> 的话，他们也会同样对你使用 <code>kill</code>。</p><h3 id="killall；killall-sb"><a href="#killall；killall-sb" class="headerlink" title="killall；killall sb"></a>killall；killall <code>sb</code></h3><p>对同一房间内的所有npc下 <code>kill</code> 指令</p><h3 id="l-look；look-sb-；look-sth-；look-方向"><a href="#l-look；look-sb-；look-sth-；look-方向" class="headerlink" title="l | look；look sb ；look sth ；look 方向"></a>l | look；look <code>sb</code> ；look <code>sth</code> ；look <code>方向</code></h3><p>看物品、人、方向等的详细信息</p><h3 id="lookin-sb"><a href="#lookin-sb" class="headerlink" title="lookin sb"></a>lookin <code>sb</code></h3><p>使你可能看清楚带面具玩家的真面目。</p><h3 id="loving"><a href="#loving" class="headerlink" title="loving"></a>loving</h3><p>夫妻间亲热的指令</p><h3 id="open-door"><a href="#open-door" class="headerlink" title="open door"></a>open door</h3><p>打开门</p><h3 id="put-sth-in-容器"><a href="#put-sth-in-容器" class="headerlink" title="put sth in 容器"></a>put <code>sth</code> in <code>容器</code></h3><p>把物品放到某容器内</p><h3 id="remove-衣服等；remove-all"><a href="#remove-衣服等；remove-all" class="headerlink" title="remove 衣服等；remove all"></a>remove <code>衣服等</code>；remove all</h3><p>脱下衣服、盔甲等</p><h3 id="reply-信息"><a href="#reply-信息" class="headerlink" title="reply 信息"></a>reply <code>信息</code></h3><p>回答刚才 <code>tell</code> 你的人</p><h3 id="say-信息"><a href="#say-信息" class="headerlink" title="say 信息"></a>say <code>信息</code></h3><p>说话，同一房间的人都可听到</p><h3 id="semote"><a href="#semote" class="headerlink" title="semote"></a>semote</h3><p>列出所有可以使用的emote</p><h3 id="shichou-sb"><a href="#shichou-sb" class="headerlink" title="shichou sb"></a>shichou <code>sb</code></h3><p>若你与别的玩家结仇，见面会自动 <code>kill</code> ，用此命令解除结仇状态</p><h3 id="sleep"><a href="#sleep" class="headerlink" title="sleep"></a>sleep</h3><p>睡觉，是快速恢复精神和体力的方法。</p><h3 id="steal-sth-from-sb"><a href="#steal-sth-from-sb" class="headerlink" title="steal sth from sb"></a>steal <code>sth</code> from <code>sb</code></h3><p>偷窃别人的东西</p><h3 id="team-sb"><a href="#team-sb" class="headerlink" title="team sb"></a>team <code>sb</code></h3><p>组织队伍</p><h3 id="tell-sb-信息"><a href="#tell-sb-信息" class="headerlink" title="tell sb 信息"></a>tell <code>sb</code> <code>信息</code></h3><p>告诉玩家一些信息，只有你们两人能看到</p><h3 id="unwield-武器"><a href="#unwield-武器" class="headerlink" title="unwield 武器"></a>unwield <code>武器</code></h3><p>放下手里的武器</p><h3 id="vote"><a href="#vote" class="headerlink" title="vote"></a>vote</h3><p>提议对某人采取行动，由大家投票决定。如果五分钟内没有人附议，投票会自动取消。当前可以有如下<code>动议</code>：</p><h4 id="chblk"><a href="#chblk" class="headerlink" title="chblk"></a>chblk</h4><p>关闭某人交谈频道，需三票以上的简单多数同意。</p><h4 id="unchblk"><a href="#unchblk" class="headerlink" title="unchblk"></a>unchblk</h4><p>打开某人交谈频道，需三票以上的三分之一票数同意。</p><h3 id="wear-衣服等；wear-all"><a href="#wear-衣服等；wear-all" class="headerlink" title="wear 衣服等；wear all"></a>wear <code>衣服等</code>；wear all</h3><p>穿上衣服，最好不要在街上裸奔….</p><h3 id="whisper-sb"><a href="#whisper-sb" class="headerlink" title="whisper sb"></a>whisper <code>sb</code></h3><p>对同一房间的人说悄悄话</p><h3 id="wield-武器"><a href="#wield-武器" class="headerlink" title="wield 武器"></a>wield <code>武器</code></h3><p>装备武器</p><h2 id="玩家命令"><a href="#玩家命令" class="headerlink" title="玩家命令"></a>玩家命令</h2><h3 id="alert"><a href="#alert" class="headerlink" title="alert"></a>alert</h3><p>朝廷官员召唤高手保护自己的命令</p><h3 id="alias"><a href="#alias" class="headerlink" title="alias"></a>alias</h3><p>设定一些命令替代系统提供的命令，可用<code>$1</code> <code>$2</code> <code>$3</code> 等参数</p><h3 id="cemote"><a href="#cemote" class="headerlink" title="cemote"></a>cemote</h3><p>模拟系统的<code>emote</code>做一个动作</p><h3 id="describe"><a href="#describe" class="headerlink" title="describe"></a>describe</h3><p>设定别人 <code>look</code> 自己时的描述</p><h3 id="destroy"><a href="#destroy" class="headerlink" title="destroy"></a>destroy</h3><p>销毁礼品</p><h3 id="do-次数-命令"><a href="#do-次数-命令" class="headerlink" title="do 次数 命令"></a>do <code>次数</code> <code>命令</code></h3><p>将命令重复10次以内</p><h3 id="femote-pattern"><a href="#femote-pattern" class="headerlink" title="femote pattern"></a>femote <code>pattern</code></h3><p>查找含有<code>pattern</code>字样的emote</p><h3 id="finger"><a href="#finger" class="headerlink" title="finger"></a>finger</h3><p>查询玩家连线资料等信息</p><h3 id="hatred"><a href="#hatred" class="headerlink" title="hatred"></a>hatred</h3><p>查询你的师门和别的门派间的关系程度</p><h3 id="help-主题"><a href="#help-主题" class="headerlink" title="help 主题"></a>help <code>主题</code></h3><p>寻求关于某一<code>主题</code>帮助</p><h3 id="hp"><a href="#hp" class="headerlink" title="hp"></a>hp</h3><p>显示自己的精神，气血等信息</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>显示自己身上的物品id</p><h3 id="inventory；i"><a href="#inventory；i" class="headerlink" title="inventory；i"></a>inventory；i</h3><p>查询自己身上的物品</p><h3 id="locate-task物品名"><a href="#locate-task物品名" class="headerlink" title="locate task物品名"></a>locate <code>task物品名</code></h3><p>查找task物品的位置</p><h3 id="maphere"><a href="#maphere" class="headerlink" title="maphere"></a>maphere</h3><p>显示附件的地图</p><h3 id="mudage"><a href="#mudage" class="headerlink" title="mudage"></a>mudage</h3><p>显示自己在mud中度过的时间</p><h3 id="news"><a href="#news" class="headerlink" title="news"></a>news</h3><p>看看有什么新闻(news很多，所以最好按照提示的方法去看news)</p><h3 id="nick"><a href="#nick" class="headerlink" title="nick"></a>nick</h3><p>给自己取个响亮的外号</p><h3 id="paihang"><a href="#paihang" class="headerlink" title="paihang"></a>paihang</h3><p>显示在线高手名单</p><h3 id="paimai"><a href="#paimai" class="headerlink" title="paimai"></a>paimai</h3><p>拍卖物品</p><h3 id="passwd"><a href="#passwd" class="headerlink" title="passwd"></a>passwd</h3><p>修改自己的mud密码</p><h3 id="jobquery"><a href="#jobquery" class="headerlink" title="jobquery"></a>jobquery</h3><p>显示自己现在需要完成的任务</p><h3 id="quit"><a href="#quit" class="headerlink" title="quit"></a>quit</h3><p>退出mud，回到现实世界</p><h3 id="save"><a href="#save" class="headerlink" title="save"></a>save</h3><p>保存自己的状态</p><h3 id="sc；score"><a href="#sc；score" class="headerlink" title="sc；score"></a>sc；score</h3><p>显示自己的主要信息</p><h3 id="set"><a href="#set" class="headerlink" title="set"></a>set</h3><p>设定一些环境变量的值</p><h3 id="setfrd"><a href="#setfrd" class="headerlink" title="setfrd"></a>setfrd</h3><p>设定好友名单</p><h3 id="setmail"><a href="#setmail" class="headerlink" title="setmail"></a>setmail</h3><p>申请@pkuxkx.net邮箱</p><h3 id="sms"><a href="#sms" class="headerlink" title="sms"></a>sms</h3><p>利用移动飞信给自己的手机发短信</p><h3 id="slaughter"><a href="#slaughter" class="headerlink" title="slaughter"></a>slaughter</h3><p>杀死自己的宠物</p><h3 id="sos"><a href="#sos" class="headerlink" title="sos"></a>sos</h3><p>向巫师求救</p><h3 id="suicide-f"><a href="#suicide-f" class="headerlink" title="suicide -f"></a>suicide -f</h3><p>再也不玩了，自杀吧。没有后悔药的，考虑清楚了</p><h3 id="task"><a href="#task" class="headerlink" title="task"></a>task</h3><p>显示task任务榜</p><h3 id="time"><a href="#time" class="headerlink" title="time"></a>time</h3><p>查询现实和mud时间</p><h3 id="title"><a href="#title" class="headerlink" title="title"></a>title</h3><p>看自己的头衔和外号等</p><h3 id="to"><a href="#to" class="headerlink" title="to"></a>to</h3><p>发送多行信息，如<code>to chat</code>；<code>to rumor</code></p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>查询一下高手排行榜</p><h3 id="tune；tune-channel"><a href="#tune；tune-channel" class="headerlink" title="tune；tune channel"></a>tune；tune <code>channel</code></h3><p>关闭自己的某个频道，无参数则显示现在收听的频道</p><h3 id="unset"><a href="#unset" class="headerlink" title="unset"></a>unset</h3><p>取消某个环境变量的设定</p><h3 id="unsetfrd"><a href="#unsetfrd" class="headerlink" title="unsetfrd"></a>unsetfrd</h3><p>取消好友设定</p><h3 id="uptime"><a href="#uptime" class="headerlink" title="uptime"></a>uptime</h3><p>显示mud运行到现在经过了多长时间</p><h3 id="version"><a href="#version" class="headerlink" title="version"></a>version</h3><p>显示mudos版本</p><h3 id="votehelpnew"><a href="#votehelpnew" class="headerlink" title="votehelpnew"></a>votehelpnew</h3><p>新手投票</p><h3 id="whistle"><a href="#whistle" class="headerlink" title="whistle"></a>whistle</h3><p>召唤自己的宠物</p><h3 id="who；who-l；who-w"><a href="#who；who-l；who-w" class="headerlink" title="who；who -l；who -w"></a>who；who -l；who -w</h3><p>显示在线玩家名单</p><h3 id="wimpy"><a href="#wimpy" class="headerlink" title="wimpy"></a>wimpy</h3><p>显示自己的wimpy参数设置</p><h3 id="wizlist"><a href="#wizlist" class="headerlink" title="wizlist"></a>wizlist</h3><p>列出巫师名单</p><h2 id="功夫相关命令"><a href="#功夫相关命令" class="headerlink" title="功夫相关命令"></a>功夫相关命令</h2><h3 id="abandon-fangqi-技能名称"><a href="#abandon-fangqi-技能名称" class="headerlink" title="abandon | fangqi 技能名称"></a>abandon | fangqi <code>技能名称</code></h3><p>放弃一项你所学过的技能，注意这里所说的「放弃」是指将这项技能从你人物的资料中删除</p><h3 id="accept-sb"><a href="#accept-sb" class="headerlink" title="accept sb"></a>accept <code>sb</code></h3><p>收某人为弟子, 如果对方也答应要拜你为师的话</p><h3 id="apprentice-bai-sb"><a href="#apprentice-bai-sb" class="headerlink" title="apprentice | bai sb"></a>apprentice | bai <code>sb</code></h3><p>拜某人为师</p><h3 id="dazuo-exercise-数值"><a href="#dazuo-exercise-数值" class="headerlink" title="dazuo | exercise 数值"></a>dazuo | exercise <code>数值</code></h3><p>将一定的气转化为内力</p><h3 id="du-study-bookname-次数"><a href="#du-study-bookname-次数" class="headerlink" title="du | study bookname 次数"></a>du | study <code>bookname</code> <code>次数</code></h3><p>通过读书提高某种技能，必须会读书识字</p><h3 id="dz"><a href="#dz" class="headerlink" title="dz"></a>dz</h3><p><code>dz</code>与<code>dazuo</code>不同的地方在于：<code>dz</code>在涨内力的同时还会增加内功的修习程度，内功等级到达一定水平后<code>dz</code>有可能会打通任督二脉，从而所有先天属性会随机增加1－2点。但在<code>dz</code>时<code>halt</code>或者战斗等可能导致走火，最大内力会减少一部分。所以最好在安全的地方dz以避免走火。</p><h3 id="enable-jifa-基本武功-特殊武功-none"><a href="#enable-jifa-基本武功-特殊武功-none" class="headerlink" title=".enable | jifa 基本武功 特殊武功 none"></a>.enable | jifa <code>基本武功</code> <code>特殊武功</code> <code>none</code></h3><p>指定所要用的特殊技能，需指明技能种类和技能名称。如果不加参数则会显示出技能种类及你目前所使用的技能名称 ，如果加一个?会列出所有能使用特殊技能的技能种类。</p><h3 id="enforce-jiali-数值"><a href="#enforce-jiali-数值" class="headerlink" title=".enforce | jiali 数值"></a>.enforce | jiali <code>数值</code></h3><p>每次击中敌人时，发出几点内力伤敌。<code>enforce none</code> 不使用内力</p><h3 id="exert-yun-功能名称-施用对象"><a href="#exert-yun-功能名称-施用对象" class="headerlink" title="exert | yun 功能名称 [施用对象]"></a>exert | yun <code>功能名称</code> [<code>施用对象</code>]</h3><p>用内力进行一些特异功能，必须 <code>enable</code> 指定你要使用的内功。<br>内功的普通功能：</p><ul><li>regenerate<br>恢复自己的精</li><li>recover<br>恢复自己的气</li></ul><p>内功的特殊功能（可能有些内功没有）：</p><ul><li>heal<br>用内力替自己疗伤</li><li>lifeheal<br>用内力替他人疗伤</li><li>.roar<br>用内力发出吼声，震昏同一房间的其他生物</li><li>powerup<br>用内力短时间内将自己的战斗力提高</li></ul><h3 id="expell-kaichu"><a href="#expell-kaichu" class="headerlink" title=".expell | kaichu"></a>.expell | kaichu</h3><p>开除不成才的弟子，被开除的弟子所有技能都会降到原来的一半</p><h3 id="learn-xue-技能-次数"><a href="#learn-xue-技能-次数" class="headerlink" title="learn | xue 技能 次数"></a>learn | xue <code>技能</code> <code>次数</code></h3><p>向别人请教有关某一种技能的疑难问题，你请教的对象在这项技能上的造诣必须比你高，而你经由这种方式学习得来的技能也不可能高於你所请教的人，请教需要消耗自己的潜能。此外学习也需要消耗一些精力，而消耗的精力跟你自己、与你学习对象的悟性有关。当你要学习的功夫等级已经高于你的师父时，再学就是以切磋的形式来学了。这时消耗的潜能、精力都是正常学习时的好几倍。除非没有更厉害的师父可以拜了，否则还是尽量拜更高级师父以保证正常的学习速度。</p><h3 id="lian-pratice-技能种类-次数"><a href="#lian-pratice-技能种类-次数" class="headerlink" title="lian | pratice 技能种类 次数"></a>lian | pratice <code>技能种类</code> <code>次数</code></h3><p>练习某个种类的技能，这个技能必须是经过 enable 的特殊技能。如果你对这方面的基本技能够高，可以经由练习直接升级，而且升级的上限不能超过你的基本技能的等级</p><h3 id="part-abandon-技能名称-级别数"><a href="#part-abandon-技能名称-级别数" class="headerlink" title="part_abandon 技能名称 级别数"></a>part_abandon <code>技能名称</code> <code>级别数</code></h3><p>放弃自己某种技能若干级。你需要调整自己的技能等级时使用</p><h3 id="perform-武功种类-招式名称-施用对象"><a href="#perform-武功种类-招式名称-施用对象" class="headerlink" title="perform [武功种类.]招式名称 [施用对象]"></a>perform [<code>武功种类</code>.]<code>招式名称</code> [<code>施用对象</code>]</h3><p>使用特殊招式，你必须先用 enable 指令指定你使用的武功，不指定武功种类时，空手的武功是指你的拳脚功夫，使用武器时则是兵刃的武功。可以用 <code>武功</code>.<code>招式</code>  的方式指定，如：太极剑法之缠字决可以用<code>perform taiji-jian.chan or perform chan</code></p><h3 id="prepare-bei-武功名称-武功名称"><a href="#prepare-bei-武功名称-武功名称" class="headerlink" title="prepare | bei 武功名称 [武功名称]"></a>prepare | bei <code>武功名称</code> [<code>武功名称</code>]</h3><p>空手武功激发以后还需要<code>bei</code>才能在战斗中使用出来，有些武功可用同时<code>bei</code>，就是互备。</p><h3 id="recruit-shou-cancel-对象"><a href="#recruit-shou-cancel-对象" class="headerlink" title="recruit | shou [cancel] | 对象"></a>recruit | shou [cancel] | <code>对象</code></h3><p>收某人为弟子，如果对方也答应要拜你为师的话</p><h3 id="respirate-tuna-数值"><a href="#respirate-tuna-数值" class="headerlink" title="respirate | tuna 数值"></a>respirate | tuna <code>数值</code></h3><p>打坐修行，将你的精转变成精力。当精力超过自己的最大精力的两倍时最大精力就会增长一点</p><h3 id="skills-cha-sb"><a href="#skills-cha-sb" class="headerlink" title="skills | cha sb"></a>skills | cha <code>sb</code></h3><p>查询自己或师徒、夫妻所学过的技能。</p><h3 id="train-动物"><a href="#train-动物" class="headerlink" title="train 动物"></a>train <code>动物</code></h3><p>训练动物，坐骑</p><h3 id="verify-武功英文名"><a href="#verify-武功英文名" class="headerlink" title="verify 武功英文名"></a>verify <code>武功英文名</code></h3><p>显示某种武功的功能及特殊招式</p><h3 id="wbei-兵器技能一-兵器技能二"><a href="#wbei-兵器技能一-兵器技能二" class="headerlink" title="wbei 兵器技能一 兵器技能二"></a>wbei <code>兵器技能一</code> <code>兵器技能二</code></h3><p>组合使用的兵器类武功，使你在战斗中能同时使用两种武功进行攻击。哪些武功可以组合，请看具体武功的帮助信息。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;纯文字不带样式的指令列表实在是看的眼疼，就整理了这一份文档&lt;/p&gt;
&lt;h2 id=&quot;标准命令&quot;&gt;&lt;a href=&quot;#标准命令&quot; class=&quot;headerlink&quot; title=&quot;标准命令&quot;&gt;&lt;/a&gt;标准命令&lt;/h2&gt;&lt;h3 id=&quot;ask-sb-about-sth&quot;&gt;&lt;a</summary>
      
    
    
    
    
    <category term="北大侠客行" scheme="https://mralridge.github.io/tags/%E5%8C%97%E5%A4%A7%E4%BE%A0%E5%AE%A2%E8%A1%8C/"/>
    
    <category term="MUD相关" scheme="https://mralridge.github.io/tags/MUD%E7%9B%B8%E5%85%B3/"/>
    
  </entry>
  
  <entry>
    <title>最后一个单词的长度</title>
    <link href="https://mralridge.github.io/2024/07/19/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/"/>
    <id>https://mralridge.github.io/2024/07/19/%E6%9C%80%E5%90%8E%E4%B8%80%E4%B8%AA%E5%8D%95%E8%AF%8D%E7%9A%84%E9%95%BF%E5%BA%A6/</id>
    <published>2024-07-19T06:48:09.000Z</published>
    <updated>2024-07-19T07:01:53.491Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个字符串 <code>s</code>，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 <strong>最后一个</strong> 单词的长度。</p><p><strong>单词</strong> 是指仅由字母组成、不包含任何空格字符的最大子字符串。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;Hello World&quot;</span><br><span class="line">输出：5</span><br><span class="line">解释：最后一个单词是“World”，长度为 5。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;   fly me   to   the moon  &quot;</span><br><span class="line">输出：4</span><br><span class="line">解释：最后一个单词是“moon”，长度为 4。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;luffy is still joyboy&quot;</span><br><span class="line">输出：6</span><br><span class="line">解释：最后一个单词是长度为 6 的“joyboy”。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅有英文字母和空格 <code>&#39; &#39;</code> 组成</li><li><code>s</code> 中至少存在一个单词</li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>因为输入字符串仅由字母和空格组成，所以抛开空格剩下的就是单词，</p><p>所以遇见非空格表示是一个字母，长度+1。</p><p>遇到空格表示一个单词结束，把有效长度记录到结果数组中。</p><p>也要注意最后一个单词可能没有空格，所以最后要手动把长度再记录一次，反正有没有空格，最后一个的长度一定是准的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLastWord</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; rets;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">                    rets.<span class="built_in">push_back</span>(ret);</span><br><span class="line">                ret = <span class="number">0</span>;</span><br><span class="line">            &#125;<span class="keyword">else</span></span><br><span class="line">                ret++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (ret &gt; <span class="number">0</span>)</span><br><span class="line">            rets.<span class="built_in">push_back</span>(ret);</span><br><span class="line">        <span class="keyword">return</span> rets.<span class="built_in">back</span>();</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><div class="note info flat"><p>也要考虑像是下面这种恶心人的输入:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x27;  fly my to the moon  &#x27;</span><br></pre></td></tr></table></figure></div>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个字符串 &lt;code&gt;s&lt;/code&gt;，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中 &lt;strong&gt;最后一个&lt;/stro</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>搜索插入位置-每日天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/19/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-%E6%AF%8F%E6%97%A5%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/19/%E6%90%9C%E7%B4%A2%E6%8F%92%E5%85%A5%E4%BD%8D%E7%BD%AE-%E6%AF%8F%E6%97%A5%E5%A4%A91LeetCode/</id>
    <published>2024-07-19T06:44:13.000Z</published>
    <updated>2024-07-19T06:47:16.884Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。</p><p>请必须使用时间复杂度为 <code>O(log n)</code> 的算法。</p><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 5</span><br><span class="line">输出: 2</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 2</span><br><span class="line">输出: 1</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: nums = [1,3,5,6], target = 7</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>提示:</p><ul><li><code>1 &lt;= nums.length &lt;= 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 为 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组</li><li><code>-104 &lt;= target &lt;= 104</code></li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><p>因为这是一个 <strong>无重复元素</strong> 的 <strong>升序</strong> 排列数组，而且题目也不会去检测原数组，所以我们只需要遍历一遍就行</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">searchInsert</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> num : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (target &lt; num)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span> (num == target)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> index;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(target &gt; num <span class="keyword">and</span> num == *(nums.<span class="built_in">end</span>()<span class="number">-1</span>))</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> nums.<span class="built_in">size</span>();</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(num &lt; target <span class="keyword">and</span> target &lt; nums[index + <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> index + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> index;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。&lt;/p&gt;
&lt;p&gt;请必</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>找出字符串中第一个匹配项的下标-每天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/18/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87-%E6%AF%8F%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/18/%E6%89%BE%E5%87%BA%E5%AD%97%E7%AC%A6%E4%B8%B2%E4%B8%AD%E7%AC%AC%E4%B8%80%E4%B8%AA%E5%8C%B9%E9%85%8D%E9%A1%B9%E7%9A%84%E4%B8%8B%E6%A0%87-%E6%AF%8F%E5%A4%A91LeetCode/</id>
    <published>2024-07-18T05:52:18.000Z</published>
    <updated>2024-07-18T05:56:56.377Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你两个字符串 <code>haystack</code> 和 <code>needle</code> ，请你在 <code>haystack</code> 字符串中找出 <code>needle</code> 字符串的第一个匹配项的下标（下标从 <code>0</code> 开始）。如果 <code>needle</code> 不是 <code>haystack</code> 的一部分，则返回 <code>-1</code> 。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;sadbutsad&quot;, needle = &quot;sad&quot;</span><br><span class="line">输出：0</span><br><span class="line">解释：&quot;sad&quot; 在下标 0 和 6 处匹配。</span><br><span class="line">第一个匹配项的下标是 0 ，所以返回 0 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：haystack = &quot;leetcode&quot;, needle = &quot;leeto&quot;</span><br><span class="line">输出：-1</span><br><span class="line">解释：&quot;leeto&quot; 没有在 &quot;leetcode&quot; 中出现，所以返回 -1 。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= haystack.length</code>, <code>needle.length &lt;= 104</code></li><li><code>haystack</code> 和 <code>needle</code> 仅由小写英文字符组成</li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>遍历每个字符,要是找到了第一个相同的字符就看看后边的字符匹不匹配就完事了,不匹配就继续找</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> ret = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">auto</span> hay = haystack.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">auto</span> need = needle.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">while</span> (hay != haystack.<span class="built_in">end</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (*hay == *need)</span><br><span class="line">            &#123;</span><br><span class="line">                ret = <span class="built_in">distance</span>(haystack.<span class="built_in">begin</span>(), hay);</span><br><span class="line">                <span class="comment">// 开始逐个比较</span></span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> index = <span class="number">1</span>;index &lt; needle.<span class="built_in">size</span>();index++)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(*(hay+index) != *(need+index))</span><br><span class="line">                    &#123;</span><br><span class="line">                        ret = <span class="number">-1</span>;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (ret != <span class="number">-1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            hay++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ret;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你两个字符串 &lt;code&gt;haystack&lt;/code&gt; 和 &lt;code&gt;needle&lt;/code&gt; ，请你在 &lt;code&gt;haystac</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>移除元素-每天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%AF%8F%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/18/%E7%A7%BB%E9%99%A4%E5%85%83%E7%B4%A0-%E6%AF%8F%E5%A4%A91LeetCode/</id>
    <published>2024-07-18T05:31:13.000Z</published>
    <updated>2024-07-18T05:53:11.951Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个数组 <code>nums</code> 和一个值 <code>val</code>，你需要 <strong>原地</strong> 移除所有数值等于 <code>val</code> 的元素。元素的顺序可能发生改变。然后返回 <code>nums</code> 中与 <code>val</code> 不同的元素的数量。</p><p>假设 <code>nums</code> 中不等于 <code>val</code> 的元素数量为 <code>k</code>，要通过此题，您需要执行以下操作：</p><p>更改 <code>nums</code> 数组，使 <code>nums</code> 的前 <code>k</code> 个元素包含不等于 <code>val</code> 的元素。<code>nums</code> 的其余元素和 <code>nums</code> 的大小并不重要。</p><p>返回 <code>k</code>。</p><p>用户评测：</p><p>评测机将使用以下代码测试您的解决方案：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="type">int</span> val = ...; <span class="comment">// 要移除的值</span></span><br><span class="line"><span class="type">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的预期答案。</span></span><br><span class="line">                            <span class="comment">// 它以不等于 val 的值排序。</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">removeElement</span>(nums, val); <span class="comment">// 调用你的实现</span></span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line"><span class="built_in">sort</span>(nums, <span class="number">0</span>, k); <span class="comment">// 排序 nums 的前 k 个元素</span></span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; actualLength; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有的断言都通过，你的解决方案将会 <strong>通过</strong>。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,2,3], val = 3</span><br><span class="line">输出：2, nums = [2,2,_,_]</span><br><span class="line">解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,1,2,2,3,0,4,2], val = 2</span><br><span class="line">输出：5, nums = [0,1,4,0,3,_,_,_]</span><br><span class="line">解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。</span><br><span class="line">注意这五个元素可以任意顺序返回。</span><br><span class="line">你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>0 &lt;= nums.length &lt;= 100</code></li><li><code>0 &lt;= nums[i] &lt;= 50</code></li><li><code>0 &lt;= val &lt;= 100</code></li></ul><h2 id="我的解法"><a href="#我的解法" class="headerlink" title="我的解法"></a>我的解法</h2><p>这题思路跟 <a href="https://mralridge.github.io/2024/07/18/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E6%AF%8F%E5%A4%A91LeetCode/">上一题</a> 很类似,但是如果和上一题一样用迭代器的话就容易进入思维陷阱,我的解法是:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">0</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[j] = __INT_MAX__;</span><br><span class="line">                i--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接把目标值改成<code>无限大</code>,最后输出之前再排一下序,反正它只看返回的前<code>k</code>位</p><h2 id="高票解法"><a href="#高票解法" class="headerlink" title="高票解法"></a>高票解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> length = nums.<span class="built_in">size</span>(), i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; length)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] == val)</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i] = nums[length - <span class="number">1</span>];</span><br><span class="line">                length--;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                ++i;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> length;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接把最后一位拿过来了,因为最终评判 <strong>只看<code>k</code>位</strong>,也 <strong>不管元素的顺序</strong>.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个数组 &lt;code&gt;nums&lt;/code&gt; 和一个值 &lt;code&gt;val&lt;/code&gt;，你需要 &lt;strong&gt;原地&lt;/strong&gt;</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>删除有序数组中的重复项-每天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/18/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E6%AF%8F%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/18/%E5%88%A0%E9%99%A4%E6%9C%89%E5%BA%8F%E6%95%B0%E7%BB%84%E4%B8%AD%E7%9A%84%E9%87%8D%E5%A4%8D%E9%A1%B9-%E6%AF%8F%E5%A4%A91LeetCode/</id>
    <published>2024-07-18T03:45:36.000Z</published>
    <updated>2024-07-18T05:32:03.244Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个 <strong>非严格递增排列</strong> 的数组 <code>nums</code> ，请你 <strong>原地</strong> 删除重复出现的元素，使每个元素 <strong>只出现一次</strong> ，返回删除后数组的新长度。元素的 <strong>相对顺序</strong> 应该保持 <strong>一致</strong> 。然后返回 <code>nums</code> 中唯一元素的个数。</p><p>考虑 <code>nums</code> 的唯一元素的数量为 <code>k</code> ，你需要做以下事情确保你的题解可以被通过：</p><p>更改数组 <code>nums</code> ，使 <code>nums</code> 的前 <code>k</code> 个元素包含唯一元素，并按照它们最初在 <code>nums</code> 中出现的顺序排列。<code>nums</code> 的其余元素与 <code>nums</code> 的大小不重要。<br>返回 <code>k</code> 。<br>判题标准:</p><p>系统会用下面的代码来测试你的题解:</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] nums = [...]; <span class="comment">// 输入数组</span></span><br><span class="line"><span class="type">int</span>[] expectedNums = [...]; <span class="comment">// 长度正确的期望答案</span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> k = <span class="built_in">removeDuplicates</span>(nums); <span class="comment">// 调用</span></span><br><span class="line"></span><br><span class="line">assert k == expectedNums.length;</span><br><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; k; i++) &#123;</span><br><span class="line">    assert nums[i] == expectedNums[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果所有断言都通过，那么您的题解将被 通过。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [1,1,2]</span><br><span class="line">输出：2, nums = [1,2,_]</span><br><span class="line">解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [0,0,1,1,1,2,2,3,3,4]</span><br><span class="line">输出：5, nums = [0,1,2,3,4]</span><br><span class="line">解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= nums.length &lt;= 3 * 104</code></li><li><code>-104 &lt;= nums[i] &lt;= 104</code></li><li><code>nums</code> 已按 <strong>非严格递增</strong> 排列</li></ul><h2 id="题解"><a href="#题解" class="headerlink" title="题解"></a>题解</h2><p>这道题因为我自己试错了半天都没解出来,所以直接看了 Top Voted Solution,才发现我把问题想复杂了</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">removeDuplicates</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> n : nums)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (!i || n &gt; nums[i<span class="number">-1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                nums[i++] = n;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这段代码主要涉及以下内容:</p><ul><li><code>!i</code>是个语法糖,用来判断<code>i</code>是否为0</li><li><code>i</code> 存储的是<code>nums</code>的索引,相当于修改原向量的部分是从头开始的</li><li>因为<code>nums</code>是 <strong>非严格递增</strong> 排列,所以只用考虑这个数是否比上一个数大</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个 &lt;strong&gt;非严格递增排列&lt;/strong&gt; 的数组 &lt;code&gt;nums&lt;/code&gt; ，请你 &lt;strong&gt;原地&lt;/st</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>有效的括号-每日1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/17/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E6%AF%8F%E6%97%A51LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/17/%E6%9C%89%E6%95%88%E7%9A%84%E6%8B%AC%E5%8F%B7-%E6%AF%8F%E6%97%A51LeetCode/</id>
    <published>2024-07-17T07:53:48.000Z</published>
    <updated>2024-07-17T08:08:19.227Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个只包括 <code>&#39;(&#39;</code>，<code>&#39;)&#39;</code>，<code>&#39;&#123;&#39;</code>，<code>&#39;&#125;&#39;</code>，<code>&#39;[&#39;</code>，<code>&#39;]&#39;</code> 的字符串 <code>s</code> ，判断字符串是否有效。</p><p>有效字符串需满足：</p><ul><li>左括号必须用相同类型的右括号闭合。</li><li>左括号必须以正确的顺序闭合。</li><li>每个右括号都有一个对应的相同类型的左括号。</li></ul><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;()[]&#123;&#125;&quot;</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：s = &quot;(]&quot;</span><br><span class="line">输出：false</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 104</code></li><li><code>s</code> 仅由括号 <code>&#39;()[]&#123;&#125;&#39;</code> 组成</li></ul><h2 id="初步解法"><a href="#初步解法" class="headerlink" title="初步解法"></a>初步解法</h2><p>用栈保存括号左侧,遇到括号右侧比较一下,最后再比较栈是否为空即可。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 奇数长度的字符串肯定不符合要求</span></span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() % <span class="number">2</span> != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; strStack = <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (s[i] != <span class="string">&#x27;\0&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (s[i] == <span class="string">&#x27;(&#x27;</span> || s[i] == <span class="string">&#x27;&#123;&#x27;</span> || s[i] == <span class="string">&#x27;[&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                strStack.<span class="built_in">push</span>(s[i]);</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="comment">// 堆中没有左符号就出现右符号的也不对</span></span><br><span class="line">                <span class="keyword">if</span> (strStack.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> ((s[i] == <span class="string">&#x27;)&#x27;</span> &amp;&amp; strStack.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span>) || (s[i] == <span class="string">&#x27;&#125;&#x27;</span> &amp;&amp; strStack.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span>) || (s[i] == <span class="string">&#x27;]&#x27;</span> &amp;&amp; strStack.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    strStack.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> strStack.<span class="built_in">size</span>() == <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="更有效率的写法"><a href="#更有效率的写法" class="headerlink" title="更有效率的写法"></a>更有效率的写法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stack&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isValid</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">char</span>&gt; str = <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> c : s)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (c == <span class="string">&#x27;(&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">or</span> c == <span class="string">&#x27;[&#x27;</span>) &#123; str.<span class="built_in">push</span>(c); &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(str.<span class="built_in">empty</span>() <span class="built_in">or</span> (str.<span class="built_in">top</span>() == <span class="string">&#x27;(&#x27;</span> <span class="keyword">and</span> c != <span class="string">&#x27;)&#x27;</span>) <span class="built_in">or</span> (str.<span class="built_in">top</span>() == <span class="string">&#x27;&#123;&#x27;</span> <span class="keyword">and</span> c != <span class="string">&#x27;&#125;&#x27;</span>) <span class="built_in">or</span> (str.<span class="built_in">top</span>() == <span class="string">&#x27;[&#x27;</span> <span class="keyword">and</span> c != <span class="string">&#x27;]&#x27;</span>))</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                str.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> str.<span class="built_in">empty</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这样做的效率更高,初步推测是用了迭代器,所以就不用每次都判断是不是<code>&#39;\0&#39;</code>,而且整体要判断的条件也少</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个只包括 &lt;code&gt;&amp;#39;(&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;)&amp;#39;&lt;/code&gt;，&lt;code&gt;&amp;#39;&amp;</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>CMAKE学习笔记</title>
    <link href="https://mralridge.github.io/2024/07/17/CMAKE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    <id>https://mralridge.github.io/2024/07/17/CMAKE%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</id>
    <published>2024-07-17T06:04:44.000Z</published>
    <updated>2024-07-17T07:40:41.492Z</updated>
    
    <content type="html"><![CDATA[<h2 id="什么是CMake"><a href="#什么是CMake" class="headerlink" title="什么是CMake"></a>什么是CMake</h2><p>众所周知,软件是代码经过编译器编译之后的产物,也就是说一个软件要在多个平台运行的话就要能够通过这些平台的编译.而每个平台所使用的编译标准都不一样,就导致如果你要发布一个跨平台的应用,就需要为这些平台都编写独立的文件,这工作量显然是不现实的.</p><p>所以就需要一种无视平台的编译流程,CMake差不多就是为用户根据平台准备编译条件的东西.</p><p>根据我之前的使用经验,使用CMake差不多是下面的流程</p><ul><li>编写CMake配置文件<code>CMakeLists.txt</code>(注意大小写)</li><li>执行命令<code>cmake PATH</code>或者</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;什么是CMake&quot;&gt;&lt;a href=&quot;#什么是CMake&quot; class=&quot;headerlink&quot; title=&quot;什么是CMake&quot;&gt;&lt;/a&gt;什么是CMake&lt;/h2&gt;&lt;p&gt;众所周知,软件是代码经过编译器编译之后的产物,也就是说一个软件要在多个平台运行的话就要能够通</summary>
      
    
    
    
    
    <category term="cmake" scheme="https://mralridge.github.io/tags/cmake/"/>
    
  </entry>
  
  <entry>
    <title>最长公共前缀-每日1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/16/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E6%AF%8F%E6%97%A51LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/16/%E6%9C%80%E9%95%BF%E5%85%AC%E5%85%B1%E5%89%8D%E7%BC%80-%E6%AF%8F%E6%97%A51LeetCode/</id>
    <published>2024-07-16T09:54:26.000Z</published>
    <updated>2024-07-16T09:57:18.913Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>编写一个函数来查找字符串数组中的最长公共前缀。</p><p>如果不存在公共前缀，返回空字符串 <code>&quot;&quot;</code>。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;flower&quot;,&quot;flow&quot;,&quot;flight&quot;]</span><br><span class="line">输出：&quot;fl&quot;</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：strs = [&quot;dog&quot;,&quot;racecar&quot;,&quot;car&quot;]</span><br><span class="line">输出：&quot;&quot;</span><br><span class="line">解释：输入不存在公共前缀。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>1 &lt;&#x3D; strs.length &lt;&#x3D; 200</li><li>0 &lt;&#x3D; strs[i].length &lt;&#x3D; 200</li><li>strs[i] 仅由小写英文字母组成</li></ul><h2 id="解法"><a href="#解法" class="headerlink" title="解法"></a>解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">longestCommonPrefix</span><span class="params">(vector&lt;string&gt;&amp; strs)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        string result = <span class="string">&quot;&quot;</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">char</span> curChar = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span>&amp; str : strs)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (str[start] == <span class="string">&#x27;\0&#x27;</span>) &#123; <span class="keyword">return</span> result; &#125;</span><br><span class="line">                <span class="keyword">if</span> (curChar == <span class="number">0</span>) &#123; curChar = str[start]; &#125;</span><br><span class="line">                <span class="keyword">if</span> (curChar != str[start])</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">return</span> result;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            result.<span class="built_in">append</span>(<span class="number">1</span>, curChar);</span><br><span class="line">            start++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>简单来说就是遍历这几个字符串同一位置的字符，任何字符串遇到<code>&#39;\0&#39;</code>就收手，这里用到了迭代器。</p><p><em>（没想到这道题第一次做就能跑出3ms的时间效率）</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;编写一个函数来查找字符串数组中的最长公共前缀。&lt;/p&gt;
&lt;p&gt;如果不存在公共前缀，返回空字符串 &lt;code&gt;&amp;quot;&amp;quot;&lt;/co</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>罗马数字转整数-每日1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/16/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0-%E6%AF%8F%E6%97%A51LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/16/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97%E8%BD%AC%E6%95%B4%E6%95%B0-%E6%AF%8F%E6%97%A51LeetCode/</id>
    <published>2024-07-16T07:39:57.000Z</published>
    <updated>2024-07-16T08:05:29.350Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>罗马数字包含以下七种字符: <code>I</code>，<code>V</code>，<code>X</code>，<code>L</code>，<code>C</code>，<code>D</code> 和 <code>M</code>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">字符          数值</span><br><span class="line">I             1</span><br><span class="line">V             5</span><br><span class="line">X             10</span><br><span class="line">L             50</span><br><span class="line">C             100</span><br><span class="line">D             500</span><br><span class="line">M             1000</span><br></pre></td></tr></table></figure><p>例如， 罗马数字 <code>2</code> 写做 <code>II</code> ，即为两个并列的 1 。<code>12</code> 写做 <code>XII</code> ，即为 <code>X</code> + <code>II</code> 。 <code>27</code> 写做  <code>XXVII</code>, 即为 <code>XX</code> + <code>V</code> + <code>II</code> 。</p><p>通常情况下，罗马数字中小的数字在大的数字的右边。但也存在特例，例如 4 不写做 <code>IIII</code>，而是 <code>IV</code>。数字 1 在数字 5 的左边，所表示的数等于大数 5 减小数 1 得到的数值 4 。同样地，数字 9 表示为 <code>IX</code>。这个特殊的规则只适用于以下六种情况：</p><ul><li><code>I</code> 可以放在 <code>V</code> (5) 和 <code>X</code> (10) 的左边，来表示 4 和 9。</li><li><code>X</code> 可以放在 <code>L</code> (50) 和 <code>C</code> (100) 的左边，来表示 40 和 90。 </li><li><code>C</code> 可以放在 <code>D</code> (500) 和 <code>M</code> (1000) 的左边，来表示 400 和 900。<br>给定一个罗马数字，将其转换成整数。</li></ul><p>示例 1:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;III&quot;</span><br><span class="line">输出: 3</span><br></pre></td></tr></table></figure><p>示例 2:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IV&quot;</span><br><span class="line">输出: 4</span><br></pre></td></tr></table></figure><p>示例 3:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;IX&quot;</span><br><span class="line">输出: 9</span><br></pre></td></tr></table></figure><p>示例 4:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;LVIII&quot;</span><br><span class="line">输出: 58</span><br><span class="line">解释: L = 50, V= 5, III = 3.</span><br></pre></td></tr></table></figure><p>示例 5:</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入: s = &quot;MCMXCIV&quot;</span><br><span class="line">输出: 1994</span><br><span class="line">解释: M = 1000, CM = 900, XC = 90, IV = 4.</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li><code>1 &lt;= s.length &lt;= 15</code></li><li><code>s</code> 仅含字符 <code>(&#39;I&#39;, &#39;V&#39;, &#39;X&#39;, &#39;L&#39;, &#39;C&#39;, &#39;D&#39;, &#39;M&#39;)</code></li><li>题目数据保证 <code>s</code> 是一个有效的罗马数字，且表示整数在范围 <code>[1, 3999]</code> 内</li><li>题目所给测试用例皆符合罗马数字书写规则，不会出现跨位等情况。</li><li>IL 和 IM 这样的例子并不符合题目要求，49 应该写作 XLIX，999 应该写作 CMXCIX 。</li><li>关于罗马数字的详尽书写规则，可以参考<a href="https://baike.baidu.com/item/%E7%BD%97%E9%A9%AC%E6%95%B0%E5%AD%97/772296">罗马数字 - 百度百科</a>。</li></ul><h2 id="普通思路"><a href="#普通思路" class="headerlink" title="普通思路"></a>普通思路</h2><p>C++里面string是由字符(char)组成的, 字符直接取值是这个字符的ASCII码，所以判断是直接取单个还是前后连起来的特殊取值就看两数之和就可以了（前提是确保小的数在前面）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> end = s.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> result = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (start != end)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 先判断两个字符的情况</span></span><br><span class="line">            <span class="type">int</span> add = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">if</span> (s[start] == <span class="number">73</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (s[start]+s[start+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">159</span>:       <span class="comment">// IV</span></span><br><span class="line">                    add = <span class="number">4</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">161</span>:       <span class="comment">// IX</span></span><br><span class="line">                    add = <span class="number">9</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">164</span>:       <span class="comment">// XL</span></span><br><span class="line">                    add = <span class="number">40</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">155</span>:       <span class="comment">// XC</span></span><br><span class="line">                    add = <span class="number">90</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">135</span>:       <span class="comment">//CD</span></span><br><span class="line">                    add = <span class="number">400</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">144</span>:       <span class="comment">//CM</span></span><br><span class="line">                    add = <span class="number">900</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (add != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    start++;</span><br><span class="line">                    result += add;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[start] == <span class="number">88</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (s[start]+s[start+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">164</span>:       <span class="comment">// XL</span></span><br><span class="line">                    add = <span class="number">40</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">155</span>:       <span class="comment">// XC</span></span><br><span class="line">                    add = <span class="number">90</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">default</span>:</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (add != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    start++;</span><br><span class="line">                    result += add;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;<span class="keyword">else</span> <span class="keyword">if</span>(s[start] == <span class="number">67</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">switch</span> (s[start]+s[start+<span class="number">1</span>])</span><br><span class="line">                &#123;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">135</span>:       <span class="comment">//CD</span></span><br><span class="line">                    add = <span class="number">400</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">case</span> <span class="number">144</span>:       <span class="comment">//CM</span></span><br><span class="line">                    add = <span class="number">900</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (add != <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    start++;</span><br><span class="line">                    start++;</span><br><span class="line">                    result += add;</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">switch</span> (s[start])</span><br><span class="line">            &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;I&#x27;</span>:</span><br><span class="line">                add = <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;V&#x27;</span>:</span><br><span class="line">                add = <span class="number">5</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;X&#x27;</span>:</span><br><span class="line">                add = <span class="number">10</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;L&#x27;</span>:</span><br><span class="line">                add = <span class="number">50</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;C&#x27;</span>:</span><br><span class="line">                add = <span class="number">100</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;D&#x27;</span>:</span><br><span class="line">                add = <span class="number">500</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">&#x27;M&#x27;</span>:</span><br><span class="line">                add = <span class="number">1000</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            start++;</span><br><span class="line">            result+=add;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><p>哈希表的特性完美契合这个需求</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">romanToInt</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; map = &#123;&#123;<span class="string">&#x27;M&#x27;</span>, <span class="number">1000</span>&#125;, &#123;<span class="string">&#x27;D&#x27;</span>, <span class="number">500</span>&#125;, &#123;<span class="string">&#x27;C&#x27;</span>, <span class="number">100</span>&#125;, &#123;<span class="string">&#x27;L&#x27;</span>, <span class="number">50</span>&#125;, &#123;<span class="string">&#x27;X&#x27;</span>, <span class="number">10</span>&#125;, &#123;<span class="string">&#x27;V&#x27;</span>, <span class="number">5</span>&#125;, &#123;<span class="string">&#x27;I&#x27;</span>, <span class="number">1</span>&#125;&#125;;</span><br><span class="line">        <span class="type">int</span> result = map[s.<span class="built_in">back</span>()]; <span class="comment">// 从最后一位的数字开始</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>() - <span class="number">1</span>; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 只要输入是合法的，那么特殊写法的最终值就是大值减去小值</span></span><br><span class="line">            <span class="keyword">if</span> (map[s[i]] &lt; map[s[i + <span class="number">1</span>]])</span><br><span class="line">            &#123;</span><br><span class="line">                result -= map[s[i]];</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                result += map[s[i]];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><em>(虽然最后我提交的结果空间效率还是没有第一种高，时间效率也没增加多少)</em></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;罗马数字包含以下七种字符: &lt;code&gt;I&lt;/code&gt;，&lt;code&gt;V&lt;/code&gt;，&lt;code&gt;X&lt;/code&gt;，&lt;code&gt;L&lt;/co</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>回文数-每天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/16/%E5%9B%9E%E6%96%87%E6%95%B0-%E6%AF%8F%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/16/%E5%9B%9E%E6%96%87%E6%95%B0-%E6%AF%8F%E5%A4%A91LeetCode/</id>
    <published>2024-07-16T03:05:16.000Z</published>
    <updated>2024-07-16T03:55:47.568Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。</p><p>回文数是指正序（从左向右）和倒序（从右向左）读都是一样的整数。</p><ul><li>例如，121 是回文，而 123 不是。</li></ul><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 121</span><br><span class="line">输出：true</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = -121</span><br><span class="line">输出：false</span><br><span class="line">解释：从左向右读, 为 -121 。 从右向左读, 为 121- 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：x = 10</span><br><span class="line">输出：false</span><br><span class="line">解释：从右向左读, 为 01 。因此它不是一个回文数。</span><br></pre></td></tr></table></figure><p>提示：</p><ul><li>-231 &lt;&#x3D; x &lt;&#x3D; 231 - 1</li></ul><p>进阶：你能不将整数转为字符串来解决这个问题吗？</p><h2 id="基础解法"><a href="#基础解法" class="headerlink" title="基础解法"></a>基础解法</h2><h3 id="使用索引的解法"><a href="#使用索引的解法" class="headerlink" title="使用索引的解法"></a>使用索引的解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 特定值是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 小于10的肯定不是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span>) &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将x转换为字符串</span></span><br><span class="line">        string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; str.<span class="built_in">length</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[i] != str[str.<span class="built_in">length</span>() - i - <span class="number">1</span>])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>直接从两边开始比较就好了</p><h3 id="使用指针的解法"><a href="#使用指针的解法" class="headerlink" title="使用指针的解法"></a>使用指针的解法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 0-9是回文数而小于0的肯定不是回文数</span></span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x &gt;= <span class="number">0</span> &amp;&amp; x &lt; <span class="number">10</span>)) &#123; <span class="keyword">return</span> x &gt;= <span class="number">0</span>; &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">// 先将x转换为字符串</span></span><br><span class="line">        string str = <span class="built_in">to_string</span>(x);</span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = str.<span class="built_in">length</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (left &lt; right)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (str[left] != str[right])</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            left++;</span><br><span class="line">            right--;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种解法要比上一种解法快不少,因为经过的判断不是很多</p><h2 id="进阶解法"><a href="#进阶解法" class="headerlink" title="进阶解法"></a>进阶解法</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isPalindrome</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (x &lt; <span class="number">0</span> || (x % <span class="number">10</span> == <span class="number">0</span> &amp;&amp; x != <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> y = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span> (x &gt; y) &#123;</span><br><span class="line">            y = y * <span class="number">10</span> + x % <span class="number">10</span>;</span><br><span class="line">            x = x / <span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (x == y || x == y / <span class="number">10</span>) &#123; <span class="keyword">return</span> <span class="literal">true</span>; &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123; <span class="keyword">return</span> <span class="literal">false</span>; &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种方法是取数字的一半,最后比较这两个一半是否相等,如果感觉不好理解的话可以看下面的表</p><table><thead><tr><th align="center">reversedHalf</th><th align="center">x</th></tr></thead><tbody><tr><td align="center">输入12321的情况</td><td align="center"></td></tr><tr><td align="center">0</td><td align="center">12321</td></tr><tr><td align="center">1</td><td align="center">1232</td></tr><tr><td align="center">12</td><td align="center">123</td></tr><tr><td align="center">123</td><td align="center">12</td></tr><tr><td align="center">输入11的情况</td><td align="center"></td></tr><tr><td align="center">0</td><td align="center">11</td></tr><tr><td align="center">1</td><td align="center">1</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给你一个整数 x ，如果 x 是一个回文整数，返回 true ；否则，返回 false 。&lt;/p&gt;
&lt;p&gt;回文数是指正序（从左向右）和倒序（</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>两数相加-每天1LeetCode</title>
    <link href="https://mralridge.github.io/2024/07/15/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E6%AF%8F%E5%A4%A91LeetCode/"/>
    <id>https://mralridge.github.io/2024/07/15/%E4%B8%A4%E6%95%B0%E7%9B%B8%E5%8A%A0-%E6%AF%8F%E5%A4%A91LeetCode/</id>
    <published>2024-07-15T09:44:23.000Z</published>
    <updated>2024-07-15T09:52:18.017Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><p>给定一个整数数组 <code>nums</code> 和一个整数目标值 <code>target</code>，请你在该数组中找出 和为目标值 <code>target</code>  的那 两个 整数，并返回它们的数组下标。</p><p>你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</p><p>你可以按任意顺序返回答案。</p><p>示例 1：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [2,7,11,15], target = 9</span><br><span class="line">输出：[0,1]</span><br><span class="line">解释：因为 nums[0] + nums[1] == 9 ，返回 [0, 1] 。</span><br></pre></td></tr></table></figure><p>示例 2：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,2,4], target = 6</span><br><span class="line">输出：[1,2]</span><br></pre></td></tr></table></figure><p>示例 3：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入：nums = [3,3], target = 6</span><br><span class="line">输出：[0,1]</span><br></pre></td></tr></table></figure><p>提示：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">2 &lt;= nums.length &lt;= 104</span><br><span class="line">-109 &lt;= nums[i] &lt;= 109</span><br><span class="line">-109 &lt;= target &lt;= 109</span><br><span class="line">只会存在一个有效答案</span><br></pre></td></tr></table></figure><p>进阶：你可以想出一个时间复杂度小于 <code>O(n2)</code> 的算法吗？</p><h2 id="解法一"><a href="#解法一" class="headerlink" title="解法一"></a>解法一</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">result</span><span class="params">(<span class="number">2</span>, <span class="number">-1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> offset = target - nums[i];</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> j = i+<span class="number">1</span>; j &lt; nums.<span class="built_in">size</span>(); j++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span> (nums[j] == offset)</span><br><span class="line">                &#123;</span><br><span class="line">                    result[<span class="number">0</span>] = i;</span><br><span class="line">                    result[<span class="number">1</span>] = j;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>这种解法比较直接，双循环比较，因为觉得比较的时候加起来比较麻烦，所以直接比较差值了</p><h2 id="解法二"><a href="#解法二" class="headerlink" title="解法二"></a>解法二</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unordered_map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">twoSum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; numMap;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; result;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> offset = target - nums[i];</span><br><span class="line">            <span class="keyword">auto</span> it = numMap.<span class="built_in">find</span>(offset);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (it != numMap.<span class="built_in">end</span>())</span><br><span class="line">            &#123;</span><br><span class="line">                result.<span class="built_in">push_back</span>(it-&gt;second);</span><br><span class="line">                result.<span class="built_in">push_back</span>(i);</span><br><span class="line">                <span class="keyword">return</span> result;</span><br><span class="line">            &#125;</span><br><span class="line">            numMap[nums[i]] = i; </span><br><span class="line">        &#125;</span><br><span class="line">        result[<span class="number">0</span>] = <span class="number">-1</span>;</span><br><span class="line">        result[<span class="number">1</span>] = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>运用哈希表，将比较过的数和它的索引都放到哈希表中，在遍历的时候直接查找哈希表中有没有符合条件的数就好了</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;题目&quot;&gt;&lt;a href=&quot;#题目&quot; class=&quot;headerlink&quot; title=&quot;题目&quot;&gt;&lt;/a&gt;题目&lt;/h2&gt;&lt;p&gt;给定一个整数数组 &lt;code&gt;nums&lt;/code&gt; 和一个整数目标值 &lt;code&gt;target&lt;/code&gt;，请你在该数组中找出 和为目标</summary>
      
    
    
    
    <category term="每天1LeetCode" scheme="https://mralridge.github.io/categories/%E6%AF%8F%E5%A4%A91LeetCode/"/>
    
    
    <category term="算法" scheme="https://mralridge.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>年轻人到底要怎样活着</title>
    <link href="https://mralridge.github.io/2024/07/12/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%88%B0%E5%BA%95%E8%A6%81%E6%80%8E%E6%A0%B7%E6%B4%BB%E7%9D%80/"/>
    <id>https://mralridge.github.io/2024/07/12/%E5%B9%B4%E8%BD%BB%E4%BA%BA%E5%88%B0%E5%BA%95%E8%A6%81%E6%80%8E%E6%A0%B7%E6%B4%BB%E7%9D%80/</id>
    <published>2024-07-12T07:38:56.000Z</published>
    <updated>2024-07-12T08:01:56.264Z</updated>
    
    <content type="html"><![CDATA[<p>从小到大我只感觉一种反差感,</p><p>对现实和梦想的反差.</p><p>我从小在小县城里长大,数学成绩一直不好.但是支撑我最初走进现在的游戏行业的是梦想,支撑我就算不想学数学,为了能够看懂代码也要学好数学.</p><p>就这样,我从一个注定要上大专的人努力成了能够上得起本科的人.</p><p>在大学之前我一直梦想着能够靠着努力出人头地,这么长时间以来我一直在学着正常人所不想学的东西,想要靠着不一样的东西出众.</p><p>这也是为什么高中的时候别人在想怎么玩,我在独自抱着&lt;C语言从入门到精通&gt;啃,事实证明这段经历也造就了我异于常人的性格.</p><p>上了大学以后,最开始我也在随波逐流,但是自从想起小时候的梦想是做出一款让大众认可的游戏,我又在努力的学游戏开发的知识,所以又开始了那种异于常人的生活.</p><p>然而现在毕业之后,我却感到迷茫.</p><p>因为家里的变故,我不得不面对现实.</p><p>现实是什么?现实就是作为一个山东人,我要承担起家庭责任,要赶快买房买车,接着结婚生孩子.</p><p>但是对我来说,这就是桎梏.</p><p>我之前所作的努力,将近10年的努力,如果就一辈子活在小县城里,是不是等于我的这些时间与精力就都浪费了呢?</p><p>而且认识的同学,朋友都去了大城市发展,也都过上了自己的生活,唯独我还在原地踏步,仿佛什么都没有做到还丢失了一些东西.</p><p>我承认现状是有我自己的原因,我也犯过很多的错.</p><p>但是我真的不想接受这个现实,自己努力的结果不被家里人肯定,甚至还没毕业就要背上房贷,给自己买房子.</p><p>本质上来说这是家里面为了我好</p><p>可,这不就是一种强买强卖吗?</p><p>在踏入社会之前,梦想着自己要出人头地,就努力撑过了自己不愿意经历的事.到头来发现你所做的一切都不被肯定,甚至家里人要你去接受那一眼看得到头的未来.</p><p>如果我未曾见过太阳,就不会渴求阳光.</p><p>我凭着热血撑到现在,我就要靠着一腔热血活到我梦想的地方去.</p><p>如果现在放弃就此认命的话,那我这一辈子可太不值了.</p><p>没有人能够剥夺我享受的权力,也没有人能够剥夺我受难的权利.无论遇到的事情是好是坏,它们都是我人生的一部分.</p><p>如果因为自己吃过苦就不让下一代去接触,那不就是变相的剥夺人生吗?</p><p>我一直在否定自己,也一直在否定环境.</p><p>因为我不知道造成今天处境的根本原因到底是我自己还是环境的原因.</p><p>真是个两难的选择.</p><p>选择接受现实,就代表着失去自己,那样的人生还算是自己的人生吗?</p><p>如果继续去追逐梦想,那无论结果,现在所做的一切努力与丢掉的东西还值得吗?</p><p>别人的世界都在过着自己想要的生活,或者是向着那个地方努力.</p><p>而我现在眼前的只有现实,要追梦就要抛弃现实,就好像我活该的一样.</p><p>我应该相信的是哪一边?</p><p>没有人能给出答案.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;从小到大我只感觉一种反差感,&lt;/p&gt;
&lt;p&gt;对现实和梦想的反差.&lt;/p&gt;
&lt;p&gt;我从小在小县城里长大,数学成绩一直不好.但是支撑我最初走进现在的游戏行业的是梦想,支撑我就算不想学数学,为了能够看懂代码也要学好数学.&lt;/p&gt;
&lt;p&gt;就这样,我从一个注定要上大专的人努力成了能够</summary>
      
    
    
    
    
    <category term="胡思乱想" scheme="https://mralridge.github.io/tags/%E8%83%A1%E6%80%9D%E4%B9%B1%E6%83%B3/"/>
    
    <category term="胡言乱语" scheme="https://mralridge.github.io/tags/%E8%83%A1%E8%A8%80%E4%B9%B1%E8%AF%AD/"/>
    
  </entry>
  
  <entry>
    <title>解决通义灵码抽风显示无权限的问题</title>
    <link href="https://mralridge.github.io/2024/07/08/%E8%A7%A3%E5%86%B3%E9%80%9A%E4%B9%89%E7%81%B5%E7%A0%81%E6%8A%BD%E9%A3%8E%E6%98%BE%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>https://mralridge.github.io/2024/07/08/%E8%A7%A3%E5%86%B3%E9%80%9A%E4%B9%89%E7%81%B5%E7%A0%81%E6%8A%BD%E9%A3%8E%E6%98%BE%E7%A4%BA%E6%97%A0%E6%9D%83%E9%99%90%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2024-07-08T01:45:40.000Z</published>
    <updated>2024-07-08T01:52:09.213Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题描述"><a href="#问题描述" class="headerlink" title="问题描述"></a>问题描述</h2><p>由于公司不方便科学上网,所以一直没用copilot,而用的是阿里的通义灵码,截止到目前(<code>2024/7/8</code>)还是限时免费,(虽然说距离我开始用的时候已经过去将近一年了).</p><p>但是今天在打开vscode的时候发现通义灵码直接给提示<code>无权限</code>了,尝试退出后登录无果,显示通义灵码域名无法解析.</p><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>打开任务管理器,杀掉<code>Lingma.exe</code>进程,之后关闭你的IDE（无论是VsCode还是Idea）,前往<code>C:\Users\你目前使用的用户</code>删除掉<code>.Lingma</code>这一整个目录，之后重启IDE登录即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;问题描述&quot;&gt;&lt;a href=&quot;#问题描述&quot; class=&quot;headerlink&quot; title=&quot;问题描述&quot;&gt;&lt;/a&gt;问题描述&lt;/h2&gt;&lt;p&gt;由于公司不方便科学上网,所以一直没用copilot,而用的是阿里的通义灵码,截止到目前(&lt;code&gt;2024/7/8&lt;/co</summary>
      
    
    
    
    <category term="赛博神医" scheme="https://mralridge.github.io/categories/%E8%B5%9B%E5%8D%9A%E7%A5%9E%E5%8C%BB/"/>
    
    
    <category term="IDE" scheme="https://mralridge.github.io/tags/IDE/"/>
    
    <category term="工作经验" scheme="https://mralridge.github.io/tags/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
  </entry>
  
  <entry>
    <title>利用Python来将抽象的染色方案表转成人能看懂的颜色</title>
    <link href="https://mralridge.github.io/2024/07/02/%E5%88%A9%E7%94%A8Python%E6%9D%A5%E5%B0%86%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E8%A1%A8%E8%BD%AC%E6%88%90%E4%BA%BA%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E9%A2%9C%E8%89%B2/"/>
    <id>https://mralridge.github.io/2024/07/02/%E5%88%A9%E7%94%A8Python%E6%9D%A5%E5%B0%86%E6%8A%BD%E8%B1%A1%E7%9A%84%E6%9F%93%E8%89%B2%E6%96%B9%E6%A1%88%E8%A1%A8%E8%BD%AC%E6%88%90%E4%BA%BA%E8%83%BD%E7%9C%8B%E6%87%82%E7%9A%84%E9%A2%9C%E8%89%B2/</id>
    <published>2024-07-02T08:11:04.000Z</published>
    <updated>2024-07-10T07:42:33.849Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0&#x2F;前言"></a>0&#x2F;前言</h1><p>工作中遇到了要更改配色方案的需求,然而目前的项目所有的配色是写在一个xml表里面的,大致结构是这样的:</p><blockquote><table><thead><tr><th align="center">ID</th><th align="center">IsFillPart1</th><th align="center">IsAddColorFirst1</th><th align="center">ColorAddFirst1</th><th align="center">HOffset1</th><th align="center">SOffset1</th><th align="center">VOffset1</th><th align="center">IsFillPart2</th><th align="center">IsAddColorFirst2</th><th align="center">ColorAddFirst2</th><th align="center">HOffset2</th><th align="center">SOffset2</th><th align="center">VOffset2</th><th align="center">IsFillPart3</th><th align="center">IsAddColorFirst3</th><th align="center">ColorAddFirst3</th><th align="center">HOffset3</th><th align="center">SOffset3</th><th align="center">VOffset3</th><th align="center">IsFillPart4</th><th align="center">IsAddColorFirst4</th><th align="center">ColorAddFirst4</th><th align="center">HOffset4</th><th align="center">SOffset4</th><th align="center">VOffset4</th><th align="center">IsFillPart5</th><th align="center">IsAddColorFirst5</th><th align="center">ColorAddFirst5</th><th align="center">HOffset5</th><th align="center">SOffset5</th><th align="center">VOffset5</th></tr></thead><tbody><tr><td align="center">1601</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0.56</td><td align="center">0.35</td><td align="center">0.24</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0.57</td><td align="center">0.2</td><td align="center">0.26</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0.63</td><td align="center">0.09</td><td align="center">0.14</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0.54</td><td align="center">-0.1</td><td align="center">0.02</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr><tr><td align="center">1603</td><td align="center">True</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0.81</td><td align="center">0.46</td><td align="center">0.15</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td><td align="center">False</td><td align="center">False</td><td align="center">0,0,0,0</td><td align="center">0</td><td align="center">0</td><td align="center">0</td></tr></tbody></table></blockquote><p>说句实在话，我看见这一堆堆的数字就头疼，更何况这些数据没有代码高亮来划分区域，所以我就在想，既然是表示颜色的数据，为什么不干脆直接把rgb数值什么的转换成颜色展示出来呢？</p><h1 id="1-看懂表"><a href="#1-看懂表" class="headerlink" title="1&#x2F;看懂表"></a>1&#x2F;看懂表</h1><p>这些表都是人写出来的，所以只要你是个人就可以读懂。</p><p>别看这个表有这么一大堆字段，仔细看的话其实可以分类成下面的结构：</p><ul><li><code>ID</code> 顾名思义，表示染色方案的id</li><li><code>IsFillPartX</code> 这里对应的是个布尔值，所以我觉得应该是角色身上编号为X的部位是否参与染色</li><li><code>IsAddColorFirstX</code> 这里对应的也是个布尔值，初步推测是代表染色方案的颜色是否叠加在原有颜色上，不然就直接覆盖了。</li><li><code>ColorAddFirstX</code> 这里对应的是颜色，格式为<code>R,G,B,A</code>，其中<code>R,G,B</code>代表红绿蓝，<code>A</code>代表透明度，但是这里的取值范围取值范围很奇怪，是<code>0-1</code>，正常的RGB取值是在<code>0-255</code>的,所以这里在后面用到的时候肯定要处理一下。</li><li><code>HOffsetX</code>,<code>SOffsetX</code>,<code>VOffsetX</code> Offset的意思是偏移，去掉Offset之后这里的意义就很明显了，就是另一种颜色格式<code>HSV</code>(色相、饱和度、亮度)的偏移量</li></ul><h1 id="2-做计划"><a href="#2-做计划" class="headerlink" title="2&#x2F;做计划"></a>2&#x2F;做计划</h1><p>现在我们看懂这个表是什么意思之后，其实这个染色方案表是怎样运行的就能了解个大差不离了。那么我们应该怎么把它转成我们能看懂的具体颜色呢?我的想法是这样的</p><p>既然他有HSV偏移这个概念，那就是说颜色的混合过程就是先将RGB颜色转换成HSV颜色，之后再将HSV偏移量加上，最后可以转回RGB颜色。</p><h1 id="3-具体代码实现"><a href="#3-具体代码实现" class="headerlink" title="3&#x2F;具体代码实现"></a>3&#x2F;具体代码实现</h1><p>我的想法是先将数据整理一下从原来的表中拿出来，只保留我们需要的字段，之后再根据我们需要的字段处理成最后的颜色。</p><p>对于拿出数据这一块，我是用下面的代码实现的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> colorsys</span><br><span class="line"><span class="keyword">import</span> os</span><br><span class="line"><span class="keyword">import</span> openpyxl</span><br><span class="line"></span><br><span class="line"><span class="keyword">def</span> <span class="title function_">value2rgb</span>(<span class="params"><span class="built_in">str</span></span>):</span><br><span class="line">    temp = <span class="built_in">str</span>.split(<span class="string">&quot;,&quot;</span>)</span><br><span class="line">    temp[<span class="number">0</span>] = <span class="built_in">int</span>(<span class="built_in">float</span>(temp[<span class="number">0</span>])*<span class="number">255</span>)</span><br><span class="line">    temp[<span class="number">1</span>] = <span class="built_in">int</span>(<span class="built_in">float</span>(temp[<span class="number">1</span>])*<span class="number">255</span>)</span><br><span class="line">    temp[<span class="number">2</span>] = <span class="built_in">int</span>(<span class="built_in">float</span>(temp[<span class="number">2</span>])*<span class="number">255</span>)</span><br><span class="line">    temp[<span class="number">3</span>] = <span class="built_in">int</span>(<span class="built_in">float</span>(temp[<span class="number">3</span>])*<span class="number">255</span>)</span><br><span class="line">    <span class="keyword">return</span> temp</span><br><span class="line"></span><br><span class="line">path = <span class="string">r&quot;你的表路径&quot;</span></span><br><span class="line">os.chdir(path)</span><br><span class="line"></span><br><span class="line">workbook = openpyxl.load_workbook(<span class="string">&quot;rawdata.xlsx&quot;</span>)</span><br><span class="line">sheet = workbook[<span class="string">&#x27;Sheet1&#x27;</span>]</span><br><span class="line"></span><br><span class="line">sheetRange = sheet.dimensions</span><br><span class="line"></span><br><span class="line">ids = sheet[<span class="string">&quot;A&quot;</span>]</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> index <span class="keyword">in</span> <span class="built_in">range</span>(<span class="number">2</span>, <span class="built_in">len</span>(ids)):</span><br><span class="line">    curId = sheet.cell(index,<span class="number">1</span>).value</span><br><span class="line">    content1 = <span class="string">&quot;&quot;</span></span><br><span class="line">    content2 = <span class="string">&quot;&quot;</span></span><br><span class="line">    content3 = <span class="string">&quot;&quot;</span></span><br><span class="line">    content4 = <span class="string">&quot;&quot;</span></span><br><span class="line">    content5 = <span class="string">&quot;&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 部位1</span></span><br><span class="line">    <span class="keyword">if</span>(sheet.cell(index,<span class="number">2</span>).value != <span class="string">&quot;False&quot;</span>):</span><br><span class="line">        rgbValue = value2rgb(sheet.cell(index,<span class="number">4</span>).value)</span><br><span class="line">        hsvValue = <span class="built_in">list</span>(colorsys.rgb_to_hsv(rgbValue[<span class="number">0</span>], rgbValue[<span class="number">1</span>], rgbValue[<span class="number">2</span>]))</span><br><span class="line">        Hoffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">5</span>).value)</span><br><span class="line">        Soffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">6</span>).value)</span><br><span class="line">        Voffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">7</span>).value)</span><br><span class="line">        <span class="comment"># 把偏移加上</span></span><br><span class="line">        hsvValue[<span class="number">0</span>] += Hoffset</span><br><span class="line">        hsvValue[<span class="number">1</span>] += Soffset</span><br><span class="line">        hsvValue[<span class="number">2</span>] += Voffset</span><br><span class="line">        rgbValue = colorsys.hsv_to_rgb(hsvValue[<span class="number">0</span>], hsvValue[<span class="number">1</span>], hsvValue[<span class="number">2</span>])</span><br><span class="line">        content1 = <span class="string">&quot;%d %d %d&quot;</span>%(rgbValue[<span class="number">0</span>],rgbValue[<span class="number">1</span>],rgbValue[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content1 = <span class="string">&quot;None&quot;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment"># 部位2</span></span><br><span class="line">    <span class="keyword">if</span>(sheet.cell(index,<span class="number">8</span>).value != <span class="string">&quot;False&quot;</span>):</span><br><span class="line">        rgbValue = value2rgb(sheet.cell(index,<span class="number">10</span>).value)</span><br><span class="line">        hsvValue = <span class="built_in">list</span>(colorsys.rgb_to_hsv(rgbValue[<span class="number">0</span>], rgbValue[<span class="number">1</span>], rgbValue[<span class="number">2</span>]))</span><br><span class="line">        Hoffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">11</span>).value)</span><br><span class="line">        Soffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">12</span>).value)</span><br><span class="line">        Voffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">13</span>).value)</span><br><span class="line">        <span class="comment"># 把偏移加上</span></span><br><span class="line">        hsvValue[<span class="number">0</span>] += Hoffset</span><br><span class="line">        hsvValue[<span class="number">1</span>] += Soffset</span><br><span class="line">        hsvValue[<span class="number">2</span>] += Voffset</span><br><span class="line">        rgbValue = colorsys.hsv_to_rgb(hsvValue[<span class="number">0</span>], hsvValue[<span class="number">1</span>], hsvValue[<span class="number">2</span>])</span><br><span class="line">        content2 = <span class="string">&quot;%d %d %d&quot;</span>%(rgbValue[<span class="number">0</span>],rgbValue[<span class="number">1</span>],rgbValue[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content2 = <span class="string">&quot;None&quot;</span></span><br><span class="line">    <span class="comment"># 部位3</span></span><br><span class="line">    <span class="keyword">if</span>(sheet.cell(index,<span class="number">14</span>).value != <span class="string">&quot;False&quot;</span>):</span><br><span class="line">        rgbValue = value2rgb(sheet.cell(index,<span class="number">16</span>).value)</span><br><span class="line">        hsvValue = <span class="built_in">list</span>(colorsys.rgb_to_hsv(rgbValue[<span class="number">0</span>], rgbValue[<span class="number">1</span>], rgbValue[<span class="number">2</span>]))</span><br><span class="line">        Hoffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">17</span>).value)</span><br><span class="line">        Soffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">18</span>).value)</span><br><span class="line">        Voffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">19</span>).value)</span><br><span class="line">        <span class="comment"># 把偏移加上</span></span><br><span class="line">        hsvValue[<span class="number">0</span>] += Hoffset</span><br><span class="line">        hsvValue[<span class="number">1</span>] += Soffset</span><br><span class="line">        hsvValue[<span class="number">2</span>] += Voffset</span><br><span class="line">        rgbValue = colorsys.hsv_to_rgb(hsvValue[<span class="number">0</span>], hsvValue[<span class="number">1</span>], hsvValue[<span class="number">2</span>])</span><br><span class="line">        content3 = <span class="string">&quot;%d %d %d&quot;</span>%(rgbValue[<span class="number">0</span>],rgbValue[<span class="number">1</span>],rgbValue[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content3 = <span class="string">&quot;None&quot;</span></span><br><span class="line">    <span class="comment"># 部位4</span></span><br><span class="line">    <span class="keyword">if</span>(sheet.cell(index,<span class="number">20</span>).value != <span class="string">&quot;False&quot;</span>):</span><br><span class="line">        rgbValue = value2rgb(sheet.cell(index,<span class="number">22</span>).value)</span><br><span class="line">        hsvValue = <span class="built_in">list</span>(colorsys.rgb_to_hsv(rgbValue[<span class="number">0</span>], rgbValue[<span class="number">1</span>], rgbValue[<span class="number">2</span>]))</span><br><span class="line">        Hoffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">23</span>).value)</span><br><span class="line">        Soffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">24</span>).value)</span><br><span class="line">        Voffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">25</span>).value)</span><br><span class="line">        <span class="comment"># 把偏移加上</span></span><br><span class="line">        hsvValue[<span class="number">0</span>] += Hoffset</span><br><span class="line">        hsvValue[<span class="number">1</span>] += Soffset</span><br><span class="line">        hsvValue[<span class="number">2</span>] += Voffset</span><br><span class="line">        rgbValue = colorsys.hsv_to_rgb(hsvValue[<span class="number">0</span>], hsvValue[<span class="number">1</span>], hsvValue[<span class="number">2</span>])</span><br><span class="line">        content4 = <span class="string">&quot;%d %d %d&quot;</span>%(rgbValue[<span class="number">0</span>],rgbValue[<span class="number">1</span>],rgbValue[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content4 = <span class="string">&quot;None&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 部位5</span></span><br><span class="line">    <span class="keyword">if</span>(sheet.cell(index,<span class="number">26</span>).value != <span class="string">&quot;False&quot;</span>):</span><br><span class="line">        rgbValue = value2rgb(sheet.cell(index,<span class="number">28</span>).value)</span><br><span class="line">        hsvValue = <span class="built_in">list</span>(colorsys.rgb_to_hsv(rgbValue[<span class="number">0</span>], rgbValue[<span class="number">1</span>], rgbValue[<span class="number">2</span>]))</span><br><span class="line">        Hoffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">29</span>).value)</span><br><span class="line">        Soffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">30</span>).value)</span><br><span class="line">        Voffset = <span class="built_in">float</span>(sheet.cell(index,<span class="number">31</span>).value)</span><br><span class="line">        <span class="comment"># 把偏移加上</span></span><br><span class="line">        hsvValue[<span class="number">0</span>] += Hoffset</span><br><span class="line">        hsvValue[<span class="number">1</span>] += Soffset</span><br><span class="line">        hsvValue[<span class="number">2</span>] += Voffset</span><br><span class="line">        rgbValue = colorsys.hsv_to_rgb(hsvValue[<span class="number">0</span>], hsvValue[<span class="number">1</span>], hsvValue[<span class="number">2</span>])</span><br><span class="line">        content5 = <span class="string">&quot;%d %d %d&quot;</span>%(rgbValue[<span class="number">0</span>],rgbValue[<span class="number">1</span>],rgbValue[<span class="number">2</span>])</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        content5 = <span class="string">&quot;None&quot;</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">    <span class="built_in">print</span>(<span class="built_in">str</span>(curId)+<span class="string">&#x27;^&#x27;</span>+content1+<span class="string">&#x27;^&#x27;</span>+content2+<span class="string">&#x27;^&#x27;</span>+content3+<span class="string">&#x27;^&#x27;</span>+content4+<span class="string">&#x27;^&#x27;</span>+content5)</span><br></pre></td></tr></table></figure><p>一上来就看这么一大坨代码确实很吓人，我们不妨先做一下准备工作</p><h2 id="3-1-前置知识"><a href="#3-1-前置知识" class="headerlink" title="3.1&#x2F;前置知识"></a>3.1&#x2F;前置知识</h2><h3 id="3-1-1-openpyxl模块"><a href="#3-1-1-openpyxl模块" class="headerlink" title="3.1.1&#x2F;openpyxl模块"></a>3.1.1&#x2F;openpyxl模块</h3><p>由于python原生不支持直接操作excel文档,所有就要用到这个模块.建议执行</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">pip install openpyxl</span><br></pre></td></tr></table></figure><p>确保这个模块存在</p><h3 id="3-1-2-colorsys模块"><a href="#3-1-2-colorsys模块" class="headerlink" title="3.1.2&#x2F;colorsys模块"></a>3.1.2&#x2F;colorsys模块</h3><p>这个模块简而言之就是用来实现颜色格式转换的,rgb转hsv然后再转回来之类的,这好像是一个Python内置的模块.</p><h2 id="3-2-具体代码实现"><a href="#3-2-具体代码实现" class="headerlink" title="3.2&#x2F;具体代码实现"></a>3.2&#x2F;具体代码实现</h2><h3 id="3-2-1-打开你的表"><a href="#3-2-1-打开你的表" class="headerlink" title="3.2.1&#x2F;打开你的表"></a>3.2.1&#x2F;打开你的表</h3>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0&amp;#x2F;前言&quot;&gt;&lt;/a&gt;0&amp;#x2F;前言&lt;/h1&gt;&lt;p&gt;工作中遇到了要更改配色方案的需求,然而目前的项目所有的配色是写在一个xml表里面的,大致结构是这样的:&lt;</summary>
      
    
    
    
    <category term="工作经验" scheme="https://mralridge.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Python" scheme="https://mralridge.github.io/tags/Python/"/>
    
    <category term="基础知识" scheme="https://mralridge.github.io/tags/%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86/"/>
    
  </entry>
  
  <entry>
    <title>在Lua中实现面向对象</title>
    <link href="https://mralridge.github.io/2024/07/01/%E5%9C%A8Lua%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://mralridge.github.io/2024/07/01/%E5%9C%A8Lua%E4%B8%AD%E5%AE%9E%E7%8E%B0%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/</id>
    <published>2024-07-01T07:56:41.000Z</published>
    <updated>2024-07-01T08:50:20.804Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0&#x2F;前言"></a>0&#x2F;前言</h1><p>可能这就是报应吧，刚开始工作的时候没好好学Lua，平常就是把它当成了python这样的其他脚本语言来用，一直没太仔细研究。到现在要做一些比较复杂的逻辑如果还是用之前那种面向过程的思想就会很受罪，所以这篇post来记录下Lua中如何实现面向对象</p><h1 id="1-面向对象的基础概念"><a href="#1-面向对象的基础概念" class="headerlink" title="1&#x2F;面向对象的基础概念"></a>1&#x2F;面向对象的基础概念</h1><p>学过面向对象语言的肯定都很清楚，面向对象语言有以下几大概念：</p><ul><li>对象(Object)</li><li>类(Class)</li><li>封装(Encapsulation)</li><li>继承(Inheritance)</li><li>多态(Polymorphism)</li></ul><p>虽然lua本身没有这样的概念，但是好在它的特性比较好用且自由，我们就利用这些特性来实现</p><h2 id="1-1-对象-Object"><a href="#1-1-对象-Object" class="headerlink" title="1.1&#x2F;对象(Object)"></a>1.1&#x2F;对象(Object)</h2><p>众所周知Lua的数据结构基本上就只有表(table)，在实际使用体验上来说，这是一把双刃剑</p><p>坏处是涉及到一些比较复杂的数据结构，要手搓的东西就比较多</p><p>好处是简单易用，基础的数据结构本质上都大差不差，直接拉一个<code>&#123;&#125;</code>出来就都能搞定。得益于表里面几乎什么东西都能放的特性，我们对表的扩展可做的事情就太多了</p><p><code>对象</code>包含<code>属性</code>与<code>方法</code></p><p>那么来到Lua，用表的话与之对应的就是<code>键值对</code>和<code>作为表的函数值</code></p><div class="note info flat"><p>现在看来这个解释有点抽象，但是看完后面的说明与代码你就能明白了</p></div><h2 id="1-2-类-Class"><a href="#1-2-类-Class" class="headerlink" title="1.2&#x2F;类(Class)"></a>1.2&#x2F;类(Class)</h2><p>面向对象里面的<code>类</code>本质上其实就是一种抽象的<code>工厂模式</code>,不妨回忆一下，类的构造函数是不是就是工厂生产产品的过程呢？</p><p>所以我们在Lua中实现类的方式就是写一个工厂函数，生产出符合类这一概念的表，再通过别的方式把这个表转化成实例</p><h2 id="1-3-封装-Encapsulation"><a href="#1-3-封装-Encapsulation" class="headerlink" title="1.3&#x2F;封装(Encapsulation)"></a>1.3&#x2F;封装(Encapsulation)</h2><p>封装可以通过元表中的<code>__index</code>和<code>__newindex</code>元方法来实现。<code>__index</code>用于访问未找到的表成员时的回溯操作，可以用来控制对私有成员的访问；而<code>__newindex</code>可以在尝试修改未定义的表成员时触发，用来限制或记录对属性的修改。</p><h2 id="1-4-继承-Inheritance"><a href="#1-4-继承-Inheritance" class="headerlink" title="1.4&#x2F;继承(Inheritance)"></a>1.4&#x2F;继承(Inheritance)</h2><p>继承可以通过让子类的元表的<code>__index</code>指向父类来实现。这样，当在子类实例中查找一个方法或属性未果时，会继续在父类中查找。仔细一想好像整个继承的概念就和<code>__index</code>做的事情很像.</p><h2 id="1-5-多态-Polymorphism"><a href="#1-5-多态-Polymorphism" class="headerlink" title="1.5&#x2F;多态(Polymorphism)"></a>1.5&#x2F;多态(Polymorphism)</h2><p>多态主要通过方法重写来实现。子类可以定义与父类同名的方法，覆盖父类的行为。此外，Lua的动态特性自然支持鸭子类型，即只要对象提供了所需的方法，就可以被正确调用，无论对象属于哪个类。</p><blockquote><p>在程序设计中，鸭子类型（英语：duck typing）是动态类型的一种风格。在这种风格中，一个对象有效的语义，不是由继承自特定的类或实现特定的接口，而是由”当前方法和属性的集合”决定。这个概念的名字来源于由James Whitcomb Riley提出的鸭子测试，“鸭子测试”可以这样表述：</p><p>“当看到一只鸟走起来像鸭子、游泳起来像鸭子、叫起来也像鸭子，那么这只鸟就可以被称为鸭子。”</p><p>在鸭子类型中，关注点在于对象的行为，能作什么；而不是关注对象所属的类型。例如，在不使用鸭子类型的语言中，我们可以编写一个函数，它接受一个类型为”鸭子”的对象，并调用它的”走”和”叫”方法。在使用鸭子类型的语言中，这样的一个函数可以接受一个任意类型的对象，并调用它的”走”和”叫”方法。如果这些需要被调用的方法不存在，那么将引发一个运行时错误。任何拥有这样的正确的”走”和”叫”方法的对象都可被函数接受的这种行为引出了以上表述，这种决定类型的方式因此得名。</p><p>(细心观察的话能发现Lua这门语言处处都是这种设计)</p></blockquote><h1 id="2-代码实现与讲解"><a href="#2-代码实现与讲解" class="headerlink" title="2&#x2F;代码实现与讲解"></a>2&#x2F;代码实现与讲解</h1><p>完整实现：</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基础的类定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = base <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    class.new = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__index</span> = class&#125;)</span><br><span class="line">        <span class="keyword">if</span> instance.init <span class="keyword">then</span> instance:init(...) <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> class</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 封装示例</span></span><br><span class="line"><span class="keyword">local</span> Person = Class()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:init</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>._name = name <span class="comment">-- 使用下划线前缀暗示这是一个私有成员</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person.getName</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>._name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Person.<span class="built_in">__index</span> = Person <span class="comment">-- 限制直接访问私有成员</span></span><br><span class="line">Person.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Cannot directly assign to private member&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 继承与多态示例</span></span><br><span class="line"><span class="keyword">local</span> Student = Class(Person)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:init</span><span class="params">(name, school)</span></span></span><br><span class="line">    Person.init(<span class="built_in">self</span>, name) <span class="comment">-- 调用父类构造函数</span></span><br><span class="line">    <span class="built_in">self</span>.school = school</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:introduce</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am &quot;</span> .. <span class="built_in">self</span>.getName(<span class="built_in">self</span>) .. <span class="string">&quot;, studying at &quot;</span> .. <span class="built_in">self</span>.school)</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"></span><br><span class="line"><span class="comment">-- 创建对象并演示</span></span><br><span class="line"><span class="keyword">local</span> alice = Person.new(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="comment">--alice._name = &quot;Bob&quot; -- 尝试修改私有成员会报错</span></span><br><span class="line"><span class="built_in">print</span>(alice.getName(alice)) <span class="comment">-- 正确访问私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bob = Student.new(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;XYZ University&quot;</span>)</span><br><span class="line">bob:introduce() <span class="comment">-- 多态示例：Student类特有的introduce方法</span></span><br></pre></td></tr></table></figure><h2 id="2-1-创建类的工厂函数"><a href="#2-1-创建类的工厂函数" class="headerlink" title="2.1&#x2F;创建类的工厂函数"></a>2.1&#x2F;创建类的工厂函数</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 基础的类定义函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Class</span><span class="params">(base)</span></span></span><br><span class="line">    <span class="keyword">local</span> class = base <span class="keyword">or</span> &#123;&#125;</span><br><span class="line">    class.new = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__index</span> = class&#125;)</span><br><span class="line">        <span class="keyword">if</span> instance.init <span class="keyword">then</span> instance:init(...) <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br><span class="line">    <span class="keyword">return</span> class</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这个函数在第一行是这样的</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> class = base <span class="keyword">or</span> &#123;&#125;</span><br></pre></td></tr></table></figure><p>对<code>Class()</code>的输入参数做了一个限定,观察后面的代码可知这是为了区分基类与子类而这样处理的，也就是说，有参数就继承父类表，否则就是全新的空表.</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">class.new = <span class="function"><span class="keyword">function</span><span class="params">(...)</span></span></span><br><span class="line">        <span class="keyword">local</span> instance = <span class="built_in">setmetatable</span>(&#123;&#125;, &#123;<span class="built_in">__index</span> = class&#125;)</span><br><span class="line">        <span class="keyword">if</span> instance.init <span class="keyword">then</span> instance:init(...) <span class="keyword">end</span></span><br><span class="line">        <span class="keyword">return</span> instance</span><br><span class="line">    <span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>创建一个新的空表<code>instance</code>作为对象实例，并为其设置一个元表（metatable）。元表中的<code>__index</code>元方法被设置为<code>class</code>，这意味着当在<code>instance</code>中找不到某个属性或方法时，Lua会去<code>class</code>表中查找。这种方式实现了方法和属性的继承，以及对实例访问未定义属性时的自动委托。</p><p>之后检查<code>instance</code>表中是否存在一个名为<code>init</code>的初始化方法。如果存在，则调用它，并将接收到的所有参数（通过<code>...</code>）传递给<code>init</code>方法。这一步是实例化过程中初始化对象状态的地方。如果是父类的话，自然没有init方法，所以不会执行，返回空表。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">return</span> class</span><br></pre></td></tr></table></figure><p>最后，Class函数返回class表，这个表现在包含了创建新对象的new方法，以及可能定义的其他类级别的属性和方法，形成了一个可以用来创建对象的“类”。</p><h2 id="2-2-对类进行封装"><a href="#2-2-对类进行封装" class="headerlink" title="2.2&#x2F;对类进行封装"></a>2.2&#x2F;对类进行封装</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 封装示例</span></span><br><span class="line"><span class="keyword">local</span> Person = Class()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:init</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>._name = name <span class="comment">-- 使用下划线前缀暗示这是一个私有成员</span></span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person.getName</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>._name</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line">Person.<span class="built_in">__index</span> = Person <span class="comment">-- 限制直接访问私有成员</span></span><br><span class="line">Person.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Cannot directly assign to private member&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这一部分就是具体对基类进行封装</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person:init</span><span class="params">(name)</span></span></span><br><span class="line">    <span class="built_in">self</span>._name = name <span class="comment">-- 使用下划线前缀暗示这是一个私有成员</span></span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这里实现的是构造函数，通过<code>self</code>来引用当前对象，<code>self._name</code>来引用当前对象的私有成员<code>_name</code>，<code>self</code>是Lua中的关键字，表示当前对象。定义了Person类的初始化方法<code>init</code>，它接收一个参数<code>name</code>，并将它存储为实例的私有属性<code>_name</code>。在Lua中，虽然没有严格的私有成员概念，但通过约定俗成，使用下划线前缀表示该成员应该是“私有的”，不应直接从外部访问或修改。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person.getName</span><span class="params">(self)</span></span></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">self</span>._name</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>提供一个公共方法<code>getName</code>，用于安全地获取私有属性<code>_name</code>的值。这样，外界可以通过这个方法访问私有成员的值，而不需要直接访问私有属性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Person.<span class="built_in">__index</span> = Person <span class="comment">-- 限制直接访问私有成员</span></span><br></pre></td></tr></table></figure><p>这行代码设置<code>Person</code>类的元表的<code>__index</code>元方法为自身。这意味着当尝试访问<code>Person</code>实例中不存在的属性时，Lua会去<code>Person</code>类中查找。这本身不直接用于限制访问，但在结合<code>__newindex</code>使用时，有助于控制属性访问。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Person.<span class="built_in">__newindex</span> = <span class="function"><span class="keyword">function</span><span class="params">(t, k, v)</span></span></span><br><span class="line">    <span class="built_in">error</span>(<span class="string">&quot;Cannot directly assign to private member&quot;</span>)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>设置<code>Person</code>类的元表的<code>__newindex</code>元方法。当尝试给<code>Person</code>的实例赋值一个不存在的键（这里通常是尝试修改私有成员）时，这个函数会被调用。在这个例子中，它抛出一个错误，阻止了对任何未明确定义的属性（特别是暗示为私有的属性）的直接赋值，从而实现了对私有成员的保护，强化了封装性。</p><h2 id="2-3-继承与多态"><a href="#2-3-继承与多态" class="headerlink" title="2.3&#x2F;继承与多态"></a>2.3&#x2F;继承与多态</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 继承与多态示例</span></span><br><span class="line"><span class="keyword">local</span> Student = Class(Person)</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:init</span><span class="params">(name, school)</span></span></span><br><span class="line">    Person.init(<span class="built_in">self</span>, name) <span class="comment">-- 调用父类构造函数</span></span><br><span class="line">    <span class="built_in">self</span>.school = school</span><br><span class="line"><span class="keyword">end</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:introduce</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am &quot;</span> .. <span class="built_in">self</span>.getName(<span class="built_in">self</span>) .. <span class="string">&quot;, studying at &quot;</span> .. <span class="built_in">self</span>.school)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>这段代码就是实际对<code>Person</code>类多态的实现</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> Student = Class(Person)</span><br></pre></td></tr></table></figure><p>这里通过指定<code>Class()</code>参数为<code>Person</code>，创建了一个父类为<code>Person</code>的子类<code>Student</code>，也就是说<code>Student</code>表会继承<code>Person</code>表中的所有属性与方法</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:init</span><span class="params">(name, school)</span></span></span><br><span class="line">    Person.init(<span class="built_in">self</span>, name) <span class="comment">-- 调用父类构造函数</span></span><br><span class="line">    <span class="built_in">self</span>.school = school</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>在<code>Student</code>类中定义一个初始化方法<code>init</code>。这个方法首先通过<code>Person.init(self, name)</code>调用了父类的初始化方法，实现了父类属性（在这个案例中是<code>name</code>）的初始化。然后，它为<code>Student</code>类添加了一个新的属性<code>school</code>，并赋予传入的值。这是继承的一个典型应用，即子类可以在保留父类特性的同时，扩展自己的特性。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Student:introduce</span><span class="params">()</span></span></span><br><span class="line">    <span class="built_in">print</span>(<span class="string">&quot;I am &quot;</span> .. <span class="built_in">self</span>.getName(<span class="built_in">self</span>) .. <span class="string">&quot;, studying at &quot;</span> .. <span class="built_in">self</span>.school)</span><br><span class="line"><span class="keyword">end</span></span><br></pre></td></tr></table></figure><p>定义了<code>Student</code>类的一个新方法<code>introduce</code>。这个方法打印出学生的名字（通过调用继承自<code>Person</code>类的<code>getName</code>方法得到）和学校名字。这里体现了多态性：尽管<code>getName</code>方法是从父类继承而来，<code>Student</code>类通过扩展自己的方法（<code>introduce</code>），以特定于子类的方式使用了这个继承的方法，展示了不同的行为。这说明即使使用了同样的方法名（如<code>getName</code>），在不同类的上下文中可以有不同的表现，符合面向对象编程中多态的概念。</p><h2 id="2-4-实例化与使用"><a href="#2-4-实例化与使用" class="headerlink" title="2.4&#x2F;实例化与使用"></a>2.4&#x2F;实例化与使用</h2><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">-- 创建对象并演示</span></span><br><span class="line"><span class="keyword">local</span> alice = Person.new(<span class="string">&quot;Alice&quot;</span>)</span><br><span class="line"><span class="comment">--alice._name = &quot;Bob&quot; -- 尝试修改私有成员会报错</span></span><br><span class="line"><span class="built_in">print</span>(alice.getName(alice)) <span class="comment">-- 正确访问私有成员</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">local</span> bob = Student.new(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;XYZ University&quot;</span>)</span><br><span class="line">bob:introduce() <span class="comment">-- 多态示例：Student类特有的introduce方法</span></span><br></pre></td></tr></table></figure><p>这一段就是对我们刚才定义的<code>Person</code>与<code>Student</code>类的实际使用</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> alice = Person.new(<span class="string">&quot;Alice&quot;</span>)</span><br></pre></td></tr></table></figure><p>这行代码通过调用<code>Person</code>类的<code>new</code>方法创建了一个名为<code>alice</code>的<code>Person</code>对象，并将名字设为”Alice”。<code>alice</code>现在是一个包含了<code>_name属性</code>（尽管是私有的）和<code>getName</code>方法等的实例。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">print</span>(alice.getName(alice)) <span class="comment">-- 正确访问私有成员</span></span><br></pre></td></tr></table></figure><p>通过调用<code>alice</code>对象的<code>getName</code>方法来间接访问其私有属性<code>_name</code>，并打印出<code>&quot;Alice&quot;</code>。这种方法允许安全地访问和展示私有数据，而不违反封装原则。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">local</span> bob = Student.new(<span class="string">&quot;Bob&quot;</span>, <span class="string">&quot;XYZ University&quot;</span>)</span><br></pre></td></tr></table></figure><p>创建了一个名为<code>bob</code>的<code>Student</code>对象，继承了<code>Person</code>类的属性和方法，并且具有额外的属性<code>school</code>，初始化为<code>&quot;XYZ University&quot;</code>。</p><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bob:introduce() <span class="comment">-- 多态示例：Student类特有的introduce方法</span></span><br></pre></td></tr></table></figure><p>调用<code>bob</code>对象的<code>introduce</code>方法，这是<code>Student</code>类新增的方法，用于介绍学生自己。这个方法展示了多态性：虽然<code>getName</code>方法是继承自<code>Person</code>类的，但通过<code>Student</code>类的上下文（即<code>introduce</code>方法），它以一种特定于<code>Student</code>类的方式来使用，即不仅打印名字，还打印学校信息。这表明，尽管方法名相同，但通过不同类的不同实现，可以产生不同的行为，是面向对象多态性的直接体现。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0&amp;#x2F;前言&quot;&gt;&lt;/a&gt;0&amp;#x2F;前言&lt;/h1&gt;&lt;p&gt;可能这就是报应吧，刚开始工作的时候没好好学Lua，平常就是把它当成了python这样的其他脚本语言来用，</summary>
      
    
    
    
    <category term="工作经验" scheme="https://mralridge.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="Lua" scheme="https://mralridge.github.io/tags/Lua/"/>
    
    <category term="面向对象" scheme="https://mralridge.github.io/tags/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    
  </entry>
  
  <entry>
    <title>有关流程图</title>
    <link href="https://mralridge.github.io/2024/07/01/%E6%9C%89%E5%85%B3%E6%B5%81%E7%A8%8B%E5%9B%BE/"/>
    <id>https://mralridge.github.io/2024/07/01/%E6%9C%89%E5%85%B3%E6%B5%81%E7%A8%8B%E5%9B%BE/</id>
    <published>2024-07-01T03:08:18.000Z</published>
    <updated>2024-07-01T03:14:35.342Z</updated>
    
    <content type="html"><![CDATA[<div class="note info flat"><p>统一规定的标准符号，不能乱用，不然就不好理解了。</p></div><p><img src="https://img-blog.csdnimg.cn/img_convert/1b269a05f6f87cb0d6b39af1a9c9aa61.png" alt="流程图标准符号"></p><div class="note info flat"><p>循环的标准结构</p></div><p><img src="https://img-blog.csdnimg.cn/img_convert/dc9578956a58fa73052567f481d7f87f.png" alt="循环的标准结构"></p><div class="note info flat"><p>注解符号的使用</p></div><p><img src="https://img-blog.csdnimg.cn/img_convert/54dc82c59758c017d8d912fec964c0d5.png" alt="注解符号的使用"></p><p>基本结构:</p><ul><li>顺序型</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/a54b3bd6cfa3d1ca25c772f2c0c600cd.png" alt="顺序型"></p><ul><li>选择型</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/3426a073beb7ac010fcbc0786c5adf15.png" alt="选择型"></p><ul><li>先判定（while）循环</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/c3cb9ce45c418e7631c43a24d70fe21e.png" alt="先while"></p><ul><li>后判定（util）循环</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/5fe4a29d89f009772966a049ce74bc24.png" alt="后until"></p><ul><li>case选择</li></ul><p><img src="https://img-blog.csdnimg.cn/img_convert/de2c6a6412c304dfdce904367f5837bf.png" alt="case"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;div class=&quot;note info flat&quot;&gt;&lt;p&gt;统一规定的标准符号，不能乱用，不然就不好理解了。&lt;/p&gt;
&lt;/div&gt;

&lt;p&gt;&lt;img src=&quot;https://img-blog.csdnimg.cn/img_convert/1b269a05f6f87cb0d6b</summary>
      
    
    
    
    
    <category term="工作技能" scheme="https://mralridge.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"/>
    
    <category term="基本功" scheme="https://mralridge.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
  </entry>
  
  <entry>
    <title>UML学习记录</title>
    <link href="https://mralridge.github.io/2024/06/29/UML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/"/>
    <id>https://mralridge.github.io/2024/06/29/UML%E5%AD%A6%E4%B9%A0%E8%AE%B0%E5%BD%95/</id>
    <published>2024-06-29T09:39:27.000Z</published>
    <updated>2024-07-01T03:02:41.840Z</updated>
    
    <content type="html"><![CDATA[<h1 id="0-什么是UML"><a href="#0-什么是UML" class="headerlink" title="0&#x2F;什么是UML?"></a>0&#x2F;什么是UML?</h1><p>UML——Unified modeling language UML(统一建模语言)，是一种用于软件系统分析和设计的语言工具，它用于帮助软件开发人员进行思考和记录思路的结果.</p><p>UML本身是一套符号的规定，就像数学符号和化学符号一样，这些符号用于描述软件模型中的各个元素和他们之间的关系，比如类、接口、实现、泛化、依赖、组合、聚合等</p><h1 id="1-UML的分类"><a href="#1-UML的分类" class="headerlink" title="1&#x2F;UML的分类"></a>1&#x2F;UML的分类</h1><h2 id="1-1-UML图"><a href="#1-1-UML图" class="headerlink" title="1.1&#x2F;UML图"></a>1.1&#x2F;UML图</h2><p>UML图本质上是将你的想法转述给别人,所以主要分为以下几类:</p><ul><li>用例图</li><li>静态结构图:类图、对象图、包图、组件图、部署图</li><li>动态行为图:交互图（时序图与协作图）、状态图、活动图</li></ul><p>类图是用来描述类与类之间的关系的，所以是UML图中最核心的。</p><h2 id="1-2-UML类图"><a href="#1-2-UML类图" class="headerlink" title="1.2&#x2F;UML类图"></a>1.2&#x2F;UML类图</h2><p>类图用于描述系统中的类（对象）本身的<code>组成</code>和类（对象）之间的各种<code>静态关系</code>,类之间的关系有：</p><ul><li>依赖</li><li>泛化（继承）</li><li>实现</li><li>关联</li><li>聚合与组合</li></ul><p>所以类图可以用以下例子来解释</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Person</span> &#123;</span><br><span class="line">    <span class="keyword">private</span> Integer id;</span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">setName</span><span class="params">(String name)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> String <span class="title function_">getName</span><span class="params">()</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>用类图就可以表示为</p><p><img src="https://s21.ax1x.com/2024/06/29/pkcpRW4.png" alt="用UML表示上面的代码"></p><h1 id="2-类图关系"><a href="#2-类图关系" class="headerlink" title="2&#x2F;类图关系"></a>2&#x2F;类图关系</h1><h2 id="2-0-类图关系概述"><a href="#2-0-类图关系概述" class="headerlink" title="2.0&#x2F;类图关系概述"></a>2.0&#x2F;类图关系概述</h2><blockquote><ul><li>设计一个类中的信息和行为要实现<code>高内聚</code></li><li>设计多个类，类之间要做到<code>低耦合</code></li></ul></blockquote><p>在实际的系统应用中，我们所<code>创建的多个对象往往是有联系</code>的, 通常情况下对象之间的关系可以分为以下几类：</p><ul><li>泛化关系</li><li>实现关系</li><li>依赖关系</li><li>关联关系</li><li>聚合关系</li><li>组合关系</li></ul><h2 id="2-1-泛化（继承）关系"><a href="#2-1-泛化（继承）关系" class="headerlink" title="2.1&#x2F;泛化（继承）关系"></a>2.1&#x2F;泛化（继承）关系</h2><p>简单的说，<code>泛化</code>就是<code>继承</code>,即一个类（我们称之为子类，子接口）继承(<code>extend</code>)另外一个类（我们称之为父类，父接口）的功能，并且可以增加自己<code>额外的</code>一些功能。</p><p>在UML关系中，继承通常使用<strong>空心三角+实线</strong>表示.</p><p>接口间的继承关系通常用圆心表示，而类之间的继承关系通常用矩形表示</p><p><img src="https://s21.ax1x.com/2024/06/29/pkc9ApQ.png" alt="UML表示类的继承"></p><h2 id="2-2-实现关系"><a href="#2-2-实现关系" class="headerlink" title="2.2&#x2F;实现关系"></a>2.2&#x2F;实现关系</h2><p>在UML关系中,实现通常使用<strong>空心三角+虚线</strong>表示</p><p>表示一个类实现一个或多个接口的功能</p><p><img src="https://s21.ax1x.com/2024/07/01/pkcgXPe.png" alt="UML表示类的实现"></p><h2 id="2-3-依赖关系"><a href="#2-3-依赖关系" class="headerlink" title="2.3&#x2F;依赖关系"></a>2.3&#x2F;依赖关系</h2><p>在UML关系中，依赖常用<strong>虚线箭头</strong>表示</p><p>表示<code>一个类依赖于另一个类的定义</code>,表示如果A对象离开了B对象，A对象无法通过编译，则此时A对象依赖于B对象（A类中使用到了B对象）</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Weapon</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> damage;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Player</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> Weapon weapon = <span class="literal">null</span>;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> damage;</span><br><span class="line">    <span class="keyword">public</span> <span class="built_in">float</span> hp;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">Attack</span>(<span class="params">Player target</span>)</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> (weapon != <span class="literal">null</span>) &#123;</span><br><span class="line">            target.hp -= weapon.damage + damage;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            target.hp -= damage;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkc2MZV.png" alt="UML表示类的依赖"></p><h2 id="2-4-关联关系"><a href="#2-4-关联关系" class="headerlink" title="2.4&#x2F;关联关系"></a>2.4&#x2F;关联关系</h2><p>UML关系中，关联关系通常使用<strong>实线箭头</strong>表示</p><h3 id="2-4-1-一对一关系"><a href="#2-4-1-一对一关系" class="headerlink" title="2.4.1&#x2F;一对一关系"></a>2.4.1&#x2F;一对一关系</h3><div class="note info flat"><p>单向关联</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QQNumber</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> QQZone zone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QQZone</span>&#123;&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkc2sRH.png" alt="单向一对一"></p><div class="note info flat"><p>双向关联</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QQNumber</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> QQZone zone;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">QQZone</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> QQNumber number;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkc22Lt.png" alt="双向一对一"></p><h3 id="2-4-2-单向的一对多"><a href="#2-4-2-单向的一对多" class="headerlink" title="2.4.2&#x2F;单向的一对多"></a>2.4.2&#x2F;单向的一对多</h3><div class="note info flat"><p>一个A对象属于多个B对象，并且每个B对象只能属于一个A对象</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Department</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> List&lt;Employee&gt; emps = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcRPyR.png" alt="单向一对多"></p><h3 id="2-4-3-单向的多对一"><a href="#2-4-3-单向的多对一" class="headerlink" title="2.4.3&#x2F;单向的多对一"></a>2.4.3&#x2F;单向的多对一</h3><div class="note info flat"><p>多个A对象属于一个B对象，并且每个A对象只能属于一个B对象</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Department</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">public</span> Department dept;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcWF3Q.png" alt="单向多对一"></p><h3 id="2-4-4-双向一对多，多对一"><a href="#2-4-4-双向一对多，多对一" class="headerlink" title="2.4.4&#x2F;双向一对多，多对一"></a>2.4.4&#x2F;双向一对多，多对一</h3><div class="note info flat"><p>A可以通过属性导航到B，B可以通过属性导航到A，本质上是把两个单向关系组合起来</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Employee</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Department dept;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Department</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Employee&gt; emps = <span class="keyword">new</span> List&lt;Employee&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcWsKA.png" alt="双向关系"></p><h3 id="2-4-5-单向多对多"><a href="#2-4-5-单向多对多" class="headerlink" title="2.4.5&#x2F;单向多对多"></a>2.4.5&#x2F;单向多对多</h3><div class="note info flat"><p>一个A对象属于多个B对象，一个B对象也属于多个A对象</p></div><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Student</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Teacher&gt; teachers = <span class="keyword">new</span> List&lt;Teacher&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Teacher</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;Student&gt; students = <span class="keyword">new</span> List&lt;Student&gt;();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcWR58.png" alt="单向多对多"></p><h2 id="2-5-聚合关系"><a href="#2-5-聚合关系" class="headerlink" title="2.5&#x2F;聚合关系"></a>2.5&#x2F;聚合关系</h2><blockquote><p>聚合关系是<code>关联关系的一种特例</code>，他体现的是<code>整体与部分</code>，是一种<code>“弱拥有”</code>的关系，即<code>has-a</code>的关系。聚合是<code>整体</code>和<code>个体</code>之间的关系</p></blockquote><p>关联关系所设计的两个类是要处在同一个层次上的，而在聚合关系中，两个类是处在不平等的层次上的，一个代表整体，一个代表部分。</p><p>聚合通常使用<strong>空心菱形+实心箭头</strong>表示</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Phone</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">class</span> <span class="title">Card</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">Card</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcfAPO.png" alt="聚合关系"></p><h2 id="2-6-组合关系"><a href="#2-6-组合关系" class="headerlink" title="2.6&#x2F;组合关系"></a>2.6&#x2F;组合关系</h2><p>组合关系也是<code>关联关系的一种特例</code>，体现的是一种<code>contains-a</code>(包含)关系，比聚合更强，所以也是<code>强聚合</code></p><blockquote><p>整体和个体不能独立存在，一定是在一个模块中同时管理整体和个体，生命周期必须相同(级联)。</p></blockquote><div class="note info flat"><p>按照我的理解就是字面意思，出现一定是”组合”起来出现，不会两个人单独出现</p></div><p>组合通常使用<strong>实心菱形+实线箭头</strong>表示</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderBill</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> List&lt;OrderBillItem&gt; items = <span class="keyword">new</span> List&lt;OrderBillItem&gt;();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title">OrderBillItem</span>&#123;</span><br><span class="line">    <span class="keyword">private</span> OrderBill bill;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="https://s21.ax1x.com/2024/07/01/pkcfWe1.png" alt="组合关系"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1 id=&quot;0-什么是UML&quot;&gt;&lt;a href=&quot;#0-什么是UML&quot; class=&quot;headerlink&quot; title=&quot;0&amp;#x2F;什么是UML?&quot;&gt;&lt;/a&gt;0&amp;#x2F;什么是UML?&lt;/h1&gt;&lt;p&gt;UML——Unified modeling language UML</summary>
      
    
    
    
    
    <category term="UML" scheme="https://mralridge.github.io/tags/UML/"/>
    
    <category term="工作技能" scheme="https://mralridge.github.io/tags/%E5%B7%A5%E4%BD%9C%E6%8A%80%E8%83%BD/"/>
    
    <category term="基本功" scheme="https://mralridge.github.io/tags/%E5%9F%BA%E6%9C%AC%E5%8A%9F/"/>
    
  </entry>
  
  <entry>
    <title>浅入浅出游戏引擎笔记（二）</title>
    <link href="https://mralridge.github.io/2024/06/29/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA2/"/>
    <id>https://mralridge.github.io/2024/06/29/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA2/</id>
    <published>2024-06-29T07:27:12.000Z</published>
    <updated>2024-06-29T09:25:15.586Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-索引与缓冲区对象"><a href="#1-索引与缓冲区对象" class="headerlink" title="1&#x2F;索引与缓冲区对象"></a>1&#x2F;索引与缓冲区对象</h2><p>在上一章的实例中,引擎主循环每执行一次,就要上传顶点数据到GPU来实现渲染.对于简单的图形来说,这是可以接受的.但是实际项目中动辄几W的顶点数量不可能也使用这种方法来处理顶点,不然每一帧都要把所有顶点上传一次,那主循环不用干别的事了.</p><p>所以要优化这种情况,有两种方式:</p><ul><li>减少数据上传量</li><li>在<code>GPU</code>上缓存数据</li></ul><p>OpenGL对应的提供了两种方法来实现,分别是<code>顶点索引</code>和<code>缓冲区对象</code>.</p><h3 id="1-1-顶点数组对象"><a href="#1-1-顶点数组对象" class="headerlink" title="1.1&#x2F;顶点数组对象"></a>1.1&#x2F;顶点数组对象</h3><p>而且各位不要忘了,OpenGL是一个典型的<code>C/S</code>架构,也就是说CPU在OpenGL里面扮演的是<code>客户端</code>的角色,而GPU在OpenGL里面扮演的是<code>服务端</code>的角色.</p><p>这就会产生一个问题:CPU在通知GPU执行一个API之后,必须等待GPU返回一个结果之后才能继续执行下一个API.换句话说,要调用的OpenGL API越多,性能就越差(要等待很多次返回结果)</p><p>那么有没有一种方法,把数个命令的结果保存在GPU上面,CPU只需要调用一个API就可以完成执行数个命令的结果呢?</p><p>答案是<code>顶点数组对象</code></p><h4 id="1-1-1-何为顶点索引"><a href="#1-1-1-何为顶点索引" class="headerlink" title="1.1.1&#x2F;何为顶点索引"></a>1.1.1&#x2F;何为顶点索引</h4><p>回顾之前画矩形的时候,我们上传了6个顶点,但是实际上只有4个顶点是真正有用的,剩余两个顶点只是为了凑出两个三角形而上传的.这样不仅增加了顶点的上传数量,也增加了GPU顶点着色器的运行次数</p><p>以正方形的顶点坐标为例,顶点坐标是一个数组,那么顶点索引就是这个数组的index</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> glm::vec3 kPositions[<span class="number">6</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一个三角形</span></span><br><span class="line">    &#123; <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//左下</span></span><br><span class="line">    &#123;  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//右下</span></span><br><span class="line">    &#123;  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//右上</span></span><br><span class="line">    <span class="comment">//第二个三角形</span></span><br><span class="line">    &#123;  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//右上</span></span><br><span class="line">    &#123; <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//左上</span></span><br><span class="line">    &#123; <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;<span class="comment">//左下</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>去掉重复的定点之后,其实只有四个顶点</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> glm::vec3 kPositions[<span class="number">4</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    &#123; <span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//左下</span></span><br><span class="line">    &#123;  <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//右下</span></span><br><span class="line">    &#123;  <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//右上</span></span><br><span class="line">    &#123; <span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">0.0f</span>&#125;,<span class="comment">//左上</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>但是只有4个顶点的情况下,如何组成两个三角形呢?答案是去重之后的顶点坐标数据不重复,但是可以新建一个数组,存储重复的顶点索引,利用索引调用顶点坐标</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> glm::vec3 indices[<span class="number">6</span>] =</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//第一个三角形</span></span><br><span class="line">    <span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,</span><br><span class="line">    <span class="comment">//第二个三角形</span></span><br><span class="line">    <span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>借助顶点索引数组,我们间接地形成了两个三角形.</p><h4 id="1-1-2-何为顶点"><a href="#1-1-2-何为顶点" class="headerlink" title="1.1.2&#x2F;何为顶点"></a>1.1.2&#x2F;何为顶点</h4><p>在作者之前的文章中,使用了如下的代码来设置了顶点的属性</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glVertexAttribPointer</span>(vpos_location, <span class="number">3</span>, GL_FLOAT, <span class="literal">false</span>, <span class="built_in">sizeof</span>(glm::vec3), kPositions);</span><br></pre></td></tr></table></figure><p>具体绘制多少个顶点,是在如下代码中决定的</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">glDrawArrays</span>(GL_TRIANGLES, <span class="number">0</span>, <span class="number">6</span>*<span class="number">6</span>);<span class="comment">//表示从第0个顶点开始画，总共画6个面，每个面6个顶点(两个三角形)。</span></span><br></pre></td></tr></table></figure><p>之前我们提到过,顶点着色器是每个顶点都要执行一次.换句话说,<code>glDrawArrays</code>制定了多少个顶点,就执行多少次.</p><blockquote><p>那么每次执行，就以当前顶点序号为下标，从<code>glVertexAttribPointer</code>设置的顶点属性去拿数据，设置到顶点shader的变量<code>vpos_location</code>中。</p><p>那么顶点属性的数据，这个数组，长度一定是要等于<code>glDrawArrays</code>指定的顶点数的，不然就会取不到数据。</p><p>按照这个逻辑，我将所有用<code>glVertexAttribPointer</code>设置的顶点属性，相同下标的，称之为一个顶点。</p></blockquote><p><img src="https://s21.ax1x.com/2024/06/29/pkcSY8J.png" alt="大概是这个意思"></p><p>也就是说,<code>一个顶点</code>包含了</p><ul><li>坐标</li><li>颜色</li><li>UV坐标</li></ul><p>三个数据,只要这三个数据有一个不同,那就不能称之为<code>两个相同的顶点</code>.也就是说,使用顶点索引需要去重,本质上是去掉三者完全相同的顶点.</p><p>因此,对于项目中存放顶点的定义<code>vertex_data.h</code>需要修改为如下代码.</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//顶点</span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">Vertex</span></span><br><span class="line">&#123;</span><br><span class="line">    glm::vec3 pos_;</span><br><span class="line">    glm::vec4 color_;</span><br><span class="line">    glm::vec2 uv_;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="type">static</span> <span class="type">const</span> Vertex kVertexs[<span class="number">36</span>] =&#123;</span><br><span class="line">    <span class="comment">//Front</span></span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">    glm::<span class="built_in">vec3</span>( <span class="number">1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">1.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>,  <span class="number">1.0f</span>, <span class="number">1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">1.0f</span>),</span><br><span class="line">    <span class="comment">//back</span></span><br><span class="line">    glm::<span class="built_in">vec3</span>(<span class="number">-1.0f</span>, <span class="number">-1.0f</span>, <span class="number">-1.0f</span>), glm::<span class="built_in">vec4</span>(<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>,<span class="number">1.0f</span>),   glm::<span class="built_in">vec2</span>(<span class="number">0.0f</span>, <span class="number">0.0f</span>),</span><br><span class="line">    <span class="comment">// ......</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>至此,我们已经模糊掉了顶点属性的概念,我们面对的是整个顶点对象.</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-索引与缓冲区对象&quot;&gt;&lt;a href=&quot;#1-索引与缓冲区对象&quot; class=&quot;headerlink&quot; title=&quot;1&amp;#x2F;索引与缓冲区对象&quot;&gt;&lt;/a&gt;1&amp;#x2F;索引与缓冲区对象&lt;/h2&gt;&lt;p&gt;在上一章的实例中,引擎主循环每执行一次,就要上传顶点数据</summary>
      
    
    
    
    <category term="浅入浅出游戏引擎" scheme="https://mralridge.github.io/categories/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    
    <category term="c++" scheme="https://mralridge.github.io/tags/c/"/>
    
    <category term="游戏引擎" scheme="https://mralridge.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%95%E6%93%8E/"/>
    
    <category term="浅入浅出" scheme="https://mralridge.github.io/tags/%E6%B5%85%E5%85%A5%E6%B5%85%E5%87%BA/"/>
    
    <category term="OpenGL" scheme="https://mralridge.github.io/tags/OpenGL/"/>
    
  </entry>
  
  <entry>
    <title>网游中常见的&quot;随机&quot;</title>
    <link href="https://mralridge.github.io/2024/06/28/%E7%BD%91%E6%B8%B8%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E6%8E%A7%E5%88%B6/"/>
    <id>https://mralridge.github.io/2024/06/28/%E7%BD%91%E6%B8%B8%E5%B8%B8%E8%A7%81%E6%A6%82%E7%8E%87%E6%8E%A7%E5%88%B6/</id>
    <published>2024-06-28T08:59:09.000Z</published>
    <updated>2024-06-28T10:00:45.019Z</updated>
    
    <content type="html"><![CDATA[<h3 id="0-前言"><a href="#0-前言" class="headerlink" title="0&#x2F;前言"></a>0&#x2F;前言</h3><p>从开始工作到现在对于游戏中的”随机”也接触了不少,这篇文章就来整理一下目前我对游戏中如何控制”随机”的看法</p><h3 id="1-从最基础的开始"><a href="#1-从最基础的开始" class="headerlink" title="1&#x2F;从最基础的开始"></a>1&#x2F;从最基础的开始</h3><p>现在让我们来设计一个玩法</p><blockquote><p>这是一个回合制RPG游戏,现在有10层地图,每层地图都有一些随时刷新的游荡小怪,击败这些小怪就可以获得某种的材料</p></blockquote><p>这样一个简单的玩法,我们有以下几种设计方法</p><h4 id="1-1-依据层数的随机"><a href="#1-1-依据层数的随机" class="headerlink" title="1.1&#x2F;依据层数的随机"></a>1.1&#x2F;依据层数的随机</h4><p>顾名思义,地图层数越高,材料的产出概率越高,同时材料的获取效率也会变高</p><p>这样设计的好处是玩家的产出与实例相绑定,驱动玩家去推进地图进度.</p><p>当然这种设计方式也有一些问题,例如</p><ul><li>材料不能与地图进度绑定(提交材料进入下层地图)</li><li>每层材料的产出需要经过调整(如果你打到最高层,每次打怪的最高产出还是和第一层一样,那就没有意思了)</li></ul><h4 id="1-2-依据次数的随机"><a href="#1-2-依据次数的随机" class="headerlink" title="1.2&#x2F;依据次数的随机"></a>1.2&#x2F;依据次数的随机</h4><p>这种方式将产出与地图分离开来,具体的做法是设定每日前XX次是一个概率,之后XXX次是一个概率,XXX次之后是固定概率</p><p>这样做的好处是可以控制玩家每日产出的大体上限,如下表所示</p><table><thead><tr><th align="center">次数</th><th align="center">不掉</th><th align="center">掉1个</th><th align="center">掉2个</th><th align="center">掉5个</th><th align="center">产出期望(E)</th><th align="center">打满可得</th></tr></thead><tbody><tr><td align="center">1-10次</td><td align="center">4000</td><td align="center">3000</td><td align="center">2000</td><td align="center">1000</td><td align="center">1.2</td><td align="center">12</td></tr><tr><td align="center">10-15次</td><td align="center">4500</td><td align="center">2900</td><td align="center">1800</td><td align="center">800</td><td align="center">1.05</td><td align="center">17.25</td></tr><tr><td align="center">15-20次</td><td align="center">5000</td><td align="center">2800</td><td align="center">1600</td><td align="center">600</td><td align="center">0.9</td><td align="center">21.75</td></tr><tr><td align="center">20-25次</td><td align="center">5500</td><td align="center">2700</td><td align="center">1400</td><td align="center">400</td><td align="center">0.75</td><td align="center">25.5</td></tr><tr><td align="center">25-30次</td><td align="center">6000</td><td align="center">2600</td><td align="center">1200</td><td align="center">200</td><td align="center">0.6</td><td align="center">28.5</td></tr><tr><td align="center">30-40次</td><td align="center">6500</td><td align="center">2300</td><td align="center">1000</td><td align="center">200</td><td align="center">0.53</td><td align="center">33.8</td></tr><tr><td align="center">40-60次</td><td align="center">8000</td><td align="center">1000</td><td align="center">800</td><td align="center">200</td><td align="center">0.36</td><td align="center">41</td></tr><tr><td align="center">60-90次</td><td align="center">9000</td><td align="center">400</td><td align="center">400</td><td align="center">200</td><td align="center">0.22</td><td align="center">47.6</td></tr><tr><td align="center">90次以上</td><td align="center">9500</td><td align="center">200</td><td align="center">200</td><td align="center">100</td><td align="center">0.11</td><td align="center"></td></tr></tbody></table><p>不过这样设计的话就只适用于材料与地图绑定的情况,此时玩家刷这个材料只是为了进入下一个地图,那么你就要在下一个地图为玩家设置足以驱动玩家打材料的奖励</p><p>(To Be Continued)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;0-前言&quot;&gt;&lt;a href=&quot;#0-前言&quot; class=&quot;headerlink&quot; title=&quot;0&amp;#x2F;前言&quot;&gt;&lt;/a&gt;0&amp;#x2F;前言&lt;/h3&gt;&lt;p&gt;从开始工作到现在对于游戏中的”随机”也接触了不少,这篇文章就来整理一下目前我对游戏中如何控制”随机”的看</summary>
      
    
    
    
    <category term="工作经验" scheme="https://mralridge.github.io/categories/%E5%B7%A5%E4%BD%9C%E7%BB%8F%E9%AA%8C/"/>
    
    
    <category term="游戏开发" scheme="https://mralridge.github.io/tags/%E6%B8%B8%E6%88%8F%E5%BC%80%E5%8F%91/"/>
    
    <category term="游戏设计" scheme="https://mralridge.github.io/tags/%E6%B8%B8%E6%88%8F%E8%AE%BE%E8%AE%A1/"/>
    
  </entry>
  
</feed>
